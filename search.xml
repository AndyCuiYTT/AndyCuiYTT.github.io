<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 沙盒机制]]></title>
    <url>%2F2018%2F05%2F31%2FiOS%20%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[iOS 每个 APP 都有自己的存储空间,这个存储空间叫做沙盒. APP可以在自己的沙盒中进行数据存取操作,但不能访问其他 app 的沙盒空间.对 app 做一些数据存储或者文件缓存时,一般都保存在沙盒中. 沙盒机制简介目录结构沙盒机制根据访问权限和功能区别分为不同的目录: document,library,temp,.app, library又包含 caches 和preferences. document: 保存应用运行时生成的需要持久化的数据iTunes会自动备份该目录。苹果建议将在应用程序中浏览到的文件数据保存在该目录下. library: 这个目录下有两个目录 caches: 一般存储的是缓存文件，例如图片视频等，此目录下的文件不会再应用程序退出时删除，在手机备份的时候，iTunes不会备份该目录。 preferences: 保存应用程序的所有偏好设置iOS的Settings(设置)，我们不应该直接在这里创建文件，而是需要通过NSUserDefault这个类来访问应用程序的偏好设置。iTunes会自动备份该文件目录下的内容. temp: 临时文件目录，在程序重新运行的时候，和开机的时候，会清空tmp文件夹。 .app: 这个就是可运行的应用文件，带有签名的文件包，包含应用程序代码和静态数据. 特点 每个应用程序都在自己的沙盒内. 不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容. 应用程序向外请求或接收数据都需要经过权限认证. 沙盒操作获取沙盒路径获取沙盒根路径1let homePath = NSHomeDirectory() 获取 document 路径1let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) 获取 library 路径1let libraryPath = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true) 获取 cache 路径1let cachePath = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) 获取 preferences 路径由系统维护,不需要我们手动获取文件目录.可借助 UserDefault 维护 获取 tmp 路径1let tmpPath = NSTemporaryDirectory() 获取程序目录和内容 获取程序包路径let path = Bundle.main.resourcePath 获取图片资源路径let imagePath = Bundle.main.path(forResource: &quot;temp&quot;, ofType: &quot;png&quot;) 文件管理iOS 对文件进行管理需要用到文件管理器: FileManager. 检测文件是否存在FileManager.default.fileExists(atPath: filePath) 创建文件路径FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil) 创建文件FileManager.default.createFile(atPath: path, contents: data, attributes: nil) 文件删除FileManager.default.removeItem(atPath: path) 文件移动FileManager.default.moveItem(atPath: oldPath, toPath: newPath) 文件复制FileManager.default.copyItem(atPath: oldPath, toPath: newPath) 获取文件属性FileManager.default.attributesOfItem(atPath: filePath)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现 cell 加载网络图片自适应方案]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%AE%9E%E7%8E%B0cell%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[UITableView 是 iOS 开发中最常用的控件之一,使用 UITaleView 时最头疼的莫过于 cell 高度的计算,虽说在 iOS8.0 以后引入了自适应方法,但在适配过程中任然会遇到各种难题,尤其是为了满足产品需求进行复杂 cell 自定义时,高度计算可谓是难上加难.这里主要对开发中遇到的自定义 cell 是加载网络图片适配问题进行总结. 在开发中为了用户能有更好体验,对网络请求多采用异步请求的方式,更有甚者对请求数据做了本地缓存.图片作为 app 中最常见的展现形式无疑是最耗流量的,对图片的处理直接影响到用户的体验,好在有大神为我们提供了好的框架(Kingfisher,SDWebImage),大大提高了我们的开发效率. 图片的异步加载提高了用户体验,却在开发中遇到了新的难题,因为图片异步加载你无法提前预知图片的尺寸,在布局时难以控制 UIImageView 的大小,如果将 UIImageView 固定大小势必会造成图片的压缩或拉伸,现在主要针对于自定义 cell 时对图片自适应布局提一些建议. 固定 UIImageView 大小在开发中我们时常会将 UIImageView 固定大小或者固定宽高比例,通过设置 ImageView 的 contentMode 属性设置图片的显示风格.该方法简单容易造成图片压缩拉伸或显示不全问题.contentMode 取值: 12345678910111213141516171819202122232425262728public enum UIViewContentMode : Int &#123; case scaleToFill //缩放内容到合适比例大小 case scaleAspectFit //缩放内容到合适的大小，边界多余部分透明 case scaleAspectFill //缩放内容填充到指定大小，边界多余的部分省略 case redraw //重绘视图边界 case center //视图保持等比缩放,居中 case top //视图顶部对齐 case bottom //视图底部对齐 case left //视图左侧对齐 case right //视图右侧对齐 case topLeft //视图左上角对齐 case topRight //视图右上角对齐 case bottomLeft //视图左下角对齐 case bottomRight //视图右下角对齐&#125; 通过获取服务器存储的图片尺寸布局在上传图片时可以将图片的大小一起上传服务器保存,在用户加载图片时将图片信息和图片 URL 地址一起返回,根据返回的图片信息计算 UIImageView 的 size 进行布局.该方法比较简单,但需要后台配合使用. 通过监听图片加载刷新 cell 实现(配合 cell 自适应)无论 SDWebiamge 还是 Kingfisher,作者都给我们提供了图片加载完回调方法,我们可以在图片加载完后重新计算 cell 高度.该方法大大加大了 cell 的刷新频率.具体步骤: 在自定义 cell 中定义闭包变量.var refreshCell: ((IndexPath) -&gt; Void)? 在图片加载完成的回调中调用闭包,为了减少 cell 的刷新,判断是拉取网络数据还是加载的缓存数据,如果是网络数据调整图片大小并将调整后图片覆盖网络加载图片,如果是缓存图片不处理. 1234567iconImageView.kf.setImage(with: URL(string: iconImageURL), placeholder: UIImage(named: "tmp")) &#123; [weak self](image, error, type, url) in if type == .none &#123; self?.iconImageView.image = self?.iconImageView.image?.ytt.resetImageSizeWithWidth(UIScreen.main.bounds.width) ImageCache.default.store((image?.ytt.resetImageSizeWithWidth(UIScreen.main.bounds.width))!, forKey: (url?.absoluteString)!) self?.refreshCell?(indexPath) &#125;&#125; 在 TableView 回调方法中实现闭包,仅当 cell 展现在屏幕时刷新 12345cell.refreshCell = &#123;(index) in if (tableView.indexPathsForVisibleRows?.contains(index))! &#123; tableView.reloadRows(at: [index], with: .automatic) &#125;&#125; 通过 ImageIO 框架获取图片信息在给 UIImageView 赋值时通过 ImageIO 获取 image 的尺寸,修改 UIImageView 的大小.该方法需要在网络请求数据,加大了数据请求量.实现代码:123456789let imageSource = CGImageSourceCreateWithURL(URL(string: iconImageURL)! as CFURL, nil)if let result = CGImageSourceCopyPropertiesAtIndex(imageSource!, 0, nil) as? Dictionary&lt;String, Any&gt; &#123; if let width = result["PixelWidth"] as? CGFloat, let height = result["PixelHeight"] as? CGFloat &#123; let h = (UIScreen.main.bounds.width - 20) / (width / height) iconImageView.snp.remakeConstraints &#123; (make) in make.height.equalTo(h) &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>cell 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carthage 安装以及初步实用]]></title>
    <url>%2F2018%2F05%2F22%2FCarthage%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本人从事 iOS 开发已有2年多,用 swift 开发也有一年多的时间了,此前一直利用 cocopods 管理三方框架和依赖,最近了解到 Carthage 这个工具,本着学习的态度对这工具进行了了解. 官方地址: https://github.com/Carthage/Carthage Carthage 简介 Carthage 类似于 CocoaPods，为用户管理第三方框架和依赖，但不会自动修改项目文件和生成配置 Carthage 是去中心化的依赖管理工具，安装依赖时不需要去中心仓库获取 CocoaPods 所有依赖的索引，节省时间 对项目无侵入性，Carthage 设计上也比较简单，利用的都是 Xcode 自身的功能，开发者在创建依赖时，相比 CocoaPods 也简单许多 Carthage 管理的依赖只需编译一次，项目干净编译时，不会再去重新编译依赖，节省时间 自动将第三方框架编程为 Dynamic framework( 动态库 )与 CocoaPods 无缝集成，一个项目能同时拥有 CocoaPods 和 Carthage 缺点： 仅支持 iOS8 + 它只支持框架，所以不能用来针对 iOS 8 以前的系统版本进行开发支持的 Carthage 安装的第三方框架和依赖不如 CocoaPods 丰富 无法在 Xcode 里定位到源码 安装包的大小比用CocoaPods安装的包大 安装 使用 Homebrew 安装 Carthage. 安装 Homebrew Install Homebrew: 获取 Homebrew 最新版本$ brew update Homebrew 常用命令 搜索$ brew search &lt;packageName&gt; 安装$ brew install &lt;packageName&gt; 卸载$ brew uninstall &lt;packageName&gt; 查看已安装包列表$ brew list 查看包信息$ brew info &lt;packageName&gt; 查看Homebrew版本$ brew -v 安装 Cartgage 安装$ brew install carthage 查看 Cartgage 版本$ carthage version 更新 carthage 版本brew upgrade carthage 删除carthage旧版本brew cleanup carthage 使用 Cartgage 安装依赖 进入项目所在路径$ cd ~/路径/项目文件夹 创建空的 Carthage 文件 Cartfile$ touch Cartfile 使用 Xcode 打开 Cartfile 文件$ open -a Xcode Cartfile 编辑 Carfile 文件(以Alamofire为例)github &quot;Alamofire/Alamofire&quot; == 4.4.0 执行更新命令,获取类库$ carthage update --platform iOS 更新完成,检查目录结构更新完成后项目根路径会多出两个文件(Cartfile.resolved,Cartfile)和一个文件夹(Carthage), Carthage下又有两个文件夹(Checkouts 和 Build), Checkouts 从github获取的源代码, Build 编译出来的Framework二进制代码库. 添加 Frameworks 到项目中 点击’项目名’ –&gt; ‘TARGETS’ –&gt; ‘General’, 在最下边找到’Linked Framework and Libraries’. 点击’+’ –&gt; ‘Add Other ..’, 选择’Carthage/Build/iOS/Alamofire.framework’,点击 ‘Open’ 导入. 选择菜单选项 ‘Build Phases’ –&gt; 点击 ‘+’ –&gt; ‘New Run Script Phase’, 添加以下命令:/usr/local/bin/carthage copy-frameworks 点击 ‘Input Files’ 下的 ‘+’,为每个 Framework 添加访问路径:$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework 在项目中 import 所需包就可以使用了.import Alamofire]]></content>
      <categories>
        <category>Other</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTTCoder]]></title>
    <url>%2F2018%2F01%2F24%2FYTTCoder%2F</url>
    <content type="text"><![CDATA[最近工作之余对开发中用到的数据解析相关进行了整理,整合了开发中常用到的数据解析,并将其封装成模块.(持续完善中) YTTCoder : 实现常用的数据解析,例如: JSON 转 Model, 字典转 JSON等 YTTJsonCodable: JSON 与 Model 之间相互转化的工具类 提供数据转化的类方法,可直接调用. YTTJson: 协议,继承Codable协议 定义 Model 实体类只需遵守该协议即可调用装换方法. YTTArrayCoder: 数组扩展类 调用使用 obj.ytt.toJson() 形式调用 toJson: 数组转 JSON 字符串 YTTDictionaryCoder: 字典扩展类 调用使用 obj.ytt.toJson() 形式调用 toJson: 字典转 JSON 字符串 getValue(withKeyPath): 根据路径获取值 YTTStringCoder: 字符串扩展类 调用使用 obj.ytt.toDictionary() 形式调用 toDictionary: JSON 字符串转字典 toArray: JSON 字符串转数组 toDate: 时间字符串转 Date 对象 YTTDateCoder: Date 扩展类 调用使用 obj.ytt.toString() 形式调用 toString: Date 格式化 反馈如果您有什么好的修改建议,可以发邮件到AndyCuiYTT@163.com, 也欢迎到我的博客AndyCuiの博客一起讨论学习~]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑共同管理hexo博客]]></title>
    <url>%2F2017%2F10%2F20%2Fhexo-version-control%2F</url>
    <content type="text"><![CDATA[使用hexo搭建博客，如果换了电脑怎么更新博客？如果你有备份源文件那还好，但是每次都要备份感觉太麻烦了。这里介绍一种方法就是使用github分支。一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。网上也有其他的方法，大家可以去搜一下，自己看看哪种适合自己，我用这种方法一方面我git命令也不太熟，所以想多写写，多学学。 先删除主题文件下的.git文件，可以直接删除或者执行下面的命令 1$ rm -rf .git 然后在本地博客文件夹下边依次输入以下指令(部分指令因为有提示可以自己修改下) 123456$ git init$ git checkout -b hexo$ git remote add origin git@github.com:vonfly（你自己giuhub账号名）/vonfly.github.io（项目名）.git$ git add .$ git commit -m "提交说明"$ git push origin hexo 执行到这里我们就已经把本地的源文件添加到了分支hexo上。 说明：博客文件夹下根目录.gitignore（此文件的作用是因此忽略所写的文件或者目录，加快push速度。）可以不修改，我的就没有修改，如果不修改的话在；另外一台电脑上克隆下来的博客项目就要先运行一下命令 1$ npm install 我的.gitignore文件内容为.DS_StoreThumbs.dbdb.json.lognode_modules/public/.deploy/ 当然你也可以把node_modules/去掉，这样在另外的电脑克隆下来的项目就不用在运行上面的命令了 扩展： github常见操作和常见错误！如果输入$ git remote add origin git@github.com:vonfly（github帐号名）/vonfly.github.io（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下：1、先输入$ git remote rm origin2、再输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git 就不会报错了！ 如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！ 如果输入$ git push origin master提示出错信息：error:failed to push som refs to …….解决办法如下：1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来2、再输入$ git push origin master3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository.4、则需要重新输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SliderView]]></title>
    <url>%2F2017%2F10%2F14%2FSliderViews%2F</url>
    <content type="text"><![CDATA[SliderViews : 简单易用的滑动标签工具,『标签栏工具』『滑动视图工具』可单独使用. 安装1pod &apos;SliderViews&apos; 使用示例SegmentedControl 使用 SegmentedControl: 标签栏工具,使用需要实现 YTTSegmentedDelegate 代理方法. 123456789let segmented = YTTSegmentedControl()segmented.delegate = self // 实现 YTTSegmentedDelegatesegmented.addTitleItems([&quot;SliderView1&quot;,&quot;SliderView2&quot;,&quot;SliderView3&quot;], isSelected: 1)segmented.backgroundColor = UIColor.cyanself.view.addSubview(segmented)segmented.snp.makeConstraints &#123; (make) in make.left.right.centerY.equalToSuperview() make.height.equalTo(50)&#125; SliderView 使用 SliderView: 滑动视图工具,使用需要实现YTTSliderViewDelegate代理 12345678910111213let sliderView = YTTSliderView()sliderView = self // 实现 YTTSliderViewDelegatelet view1 = UIView()view1.backgroundColor = UIColor.cyanlet view2 = UIView()view2.backgroundColor = UIColor.orangelet view3 = UIView()view3.backgroundColor = UIColor.bluesliderView.addChildViews([view1, view2, view3], isSelected: 1)self.view.addSubview(sliderView)sliderView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview()&#125; TabSliderView 使用 TabSliderView: SegmentedControl 与 SliderView 组合使用. 123456let tabSliderView = YTTTabSliderView()tabSliderView.addSubviews([(&quot;SliderView1&quot;,view1),(&quot;SliderView2&quot;,view2),(&quot;SliderView3&quot;,view3)])view.addSubview(tabSliderView)tabSliderView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview()&#125; 反馈如果您有什么好的修改建议,可以发邮件到AndyCuiYTT@163.com, 也欢迎到我的博客AndyCuiの博客一起讨论学习~]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>slider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift处理JSON - 转换JSON和Model]]></title>
    <url>%2F2017%2F08%2F29%2FSwift%E5%A4%84%E7%90%86JSON%20-%20%E8%BD%AC%E6%8D%A2JSON%E5%92%8CModel%2F</url>
    <content type="text"><![CDATA[背景&emsp;&emsp;很多时候我们再服务端请求下来的数据都是JSON格式，我们需要将这些数据展示在UI界面。我们一般都会先将JSON转化为数据模型或字典进行使用。&emsp;&emsp;为了更快的开发我们时常会用到一些开源库，其中JSON解析的库必不可少，在OC开发中我们常用的JSON解析库如MJExtension，JSONModel等,这些库基本都是利用runtime实现读取属性并利用kvc赋值的。在swift中由于runtime的局限性，产生了一些通过反射等机制实现的库，比如SwiftyJSON，ObjectMapper，HandyJSON等，而 HandyJSON 是其中使用最舒服的一个库，本文将介绍用 HandyJSON 来进行Model和JSON间的互相转换。 简单示例反序列化1234567891011121314class BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String! required init() &#123;&#125;&#125;let jsonString = "&#123;\"doubleOptional\":1.1,\"stringImplicitlyUnwrapped\":\"hello\",\"int\":1&#125;"if let object = BasicTypes.deserialize(from: jsonString) &#123; print(object.int) print(object.doubleOptional!) print(object.stringImplicitlyUnwrapped)&#125; 序列化12345678let object = BasicTypes()object.int = 1object.doubleOptional = 1.1object.stringImplicitlyUnwrapped = “hello"print(object.toJSON()!) // serialize to dictionaryprint(object.toJSONString()!) // serialize to JSON stringprint(object.toJSONString(prettyPrint: true)!) // serialize to pretty JSON string 文档目录 特性 环境要求 安装 反序列化 基本类型 支持struct 支持enum 可选、隐式解包可选、集合等 指定解析路径 组合对象 继承自父类的子类 JSON中的数组 自定义解析规则 排除指定属性 支持的属性类型 序列化 基本类型 自定义映射和排除型 待办 特性 序列化Model到JSON、从JSON反序列化到Model 自然地以Model的属性名称作为解析JSON的Key，不需要额外指定 支持Swift中大部分类型 支持class、struct定义的Model 支持自定义解析规则 类型自适应，如JSON中是一个Int，但对应Model是String字段，会自动完成转化 具体支持的类型，可以参考代码文件: BasicTypes。 环境要求 iOS 8.0+/OSX 10.9+/watchOS 2.0+/tvOS 9.0+ Swift 2.3+ / Swift 3.0+ 安装HandyJSON只在Swift3.x版本上(master分支)开发新特性，在Swift2.x中使用，参见: swift2 branch 具体操作指引参考 英文版README 的 Installation 章节。 反序列化基本类型要支持从JSON串反序列化，Model定义时要声明服从HandyJSON协议。确实是一个协议，而不是继承自NSObject。 服从HandyJSON协议，需要实现一个空的init方法。 123456789101112class BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String! required init() &#123;&#125;&#125;let jsonString = "&#123;\"doubleOptional\":1.1,\"stringImplicitlyUnwrapped\":\"hello\",\"int\":1&#125;"if let object = BasicTypes.deserialize(from: jsonString) &#123; // …&#125; 支持struct对于声明为struct的Model，由于struct默认提供了空的init方法，所以不需要额外声明。 12345678910struct BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String!&#125;let jsonString = "&#123;\"doubleOptional\":1.1,\"stringImplicitlyUnwrapped\":\"hello\",\"int\":1&#125;"if let object = BasicTypes.deserialize(from: jsonString) &#123; // …&#125; 但需要注意，如果你为struct指定了别的构造函数，那就要显示声明一个空的init函数。 支持enum支持值类型的enum，且需要声明服从HandyJSONEnum协议。不再需要其他特殊处理了。 123456789101112131415enum AnimalType: String, HandyJSONEnum &#123; case Cat = "cat" case Dog = "dog" case Bird = "bird"&#125;struct Animal: HandyJSON &#123; var name: String? var type: AnimalType?&#125;let jsonString = "&#123;\"type\":\"cat\",\"name\":\"Tom\"&#125;"if let animal = Animal.deserialize(from: jsonString) &#123; print(animal.type?.rawValue)&#125; 可选、隐式解包可选、集合等HandyJSON支持这些非基础类型，包括嵌套结构。 123456789101112131415161718192021222324252627282930313233class BasicTypes: HandyJSON &#123; var bool: Bool = true var intOptional: Int? var doubleImplicitlyUnwrapped: Double! var anyObjectOptional: Any? var arrayInt: Array&lt;Int&gt; = [] var arrayStringOptional: Array&lt;String&gt;? var setInt: Set&lt;Int&gt;? var dictAnyObject: Dictionary&lt;String, Any&gt; = [:] var nsNumber = 2 var nsString: NSString? required init() &#123;&#125;&#125;let object = BasicTypes()object.intOptional = 1object.doubleImplicitlyUnwrapped = 1.1object.anyObjectOptional = "StringValue"object.arrayInt = [1, 2]object.arrayStringOptional = ["a", "b"]object.setInt = [1, 2]object.dictAnyObject = ["key1": 1, "key2": "stringValue"]object.nsNumber = 2object.nsString = "nsStringValue"let jsonString = object.toJSONString()!if let object = BasicTypes.deserialize(from: jsonString) &#123; // ...&#125; 指定解析路径HandyJSON支持指定从哪个具体路径开始解析，反序列化到Model。 123456789101112class Cat: HandyJSON &#123; var id: Int64! var name: String! required init() &#123;&#125;&#125;let jsonString = "&#123;\"code\":200,\"msg\":\"success\",\"data\":&#123;\"cat\":&#123;\"id\":12345,\"name\":\"Kitty\"&#125;&#125;&#125;"if let cat = Cat.deserialize(from: jsonString, designatedPath: "data.cat") &#123; print(cat.name)&#125; 组合对象注意，如果Model的属性不是基本类型或集合类型，那么它必须是一个服从HandyJSON协议的类型。 如果是泛型集合类型，那么要求泛型实参是基本类型或者服从HandyJSON协议的类型。 1234567891011121314151617181920class Component: HandyJSON &#123; var aInt: Int? var aString: String? required init() &#123;&#125;&#125;class Composition: HandyJSON &#123; var aInt: Int? var comp1: Component? var comp2: Component? required init() &#123;&#125;&#125;let jsonString = "&#123;\"num\":12345,\"comp1\":&#123;\"aInt\":1,\"aString\":\"aaaaa\"&#125;,\"comp2\":&#123;\"aInt\":2,\"aString\":\"bbbbb\"&#125;&#125;"if let composition = Composition.deserialize(from: jsonString) &#123; print(composition)&#125; 继承自父类的子类如果子类要支持反序列化，那么要求父类也服从HandyJSON协议。 123456789101112131415161718class Animal: HandyJSON &#123; var id: Int? var color: String? required init() &#123;&#125;&#125;class Cat: Animal &#123; var name: String? required init() &#123;&#125;&#125;let jsonString = "&#123;\"id\":12345,\"color\":\"black\",\"name\":\"cat\"&#125;"if let cat = Cat.deserialize(from: jsonString) &#123; print(cat)&#125; JSON数组如果JSON的第一层表达的是数组，可以转化它到一个Model数组。 12345678910111213class Cat: HandyJSON &#123; var name: String? var id: String? required init() &#123;&#125;&#125;let jsonArrayString: String? = "[&#123;\"name\":\"Bob\",\"id\":\"1\"&#125;, &#123;\"name\":\"Lily\",\"id\":\"2\"&#125;, &#123;\"name\":\"Lucy\",\"id\":\"3\"&#125;]"if let cats = [Cat].deserialize(from: jsonArrayString) &#123; cats.forEach(&#123; (cat) in // ... &#125;)&#125; 自定义解析规则HandyJSON支持自定义映射关系，或者自定义解析过程。你需要实现一个可选的mapping函数，在里边实现NSString值(HandyJSON会把对应的JSON字段转换为NSString)转换为你需要的字段类型。 12345678910111213141516171819202122232425262728293031323334class Cat: HandyJSON &#123; var id: Int64! var name: String! var parent: (String, String)? required init() &#123;&#125; func mapping(mapper: HelpingMapper) &#123; // specify 'cat_id' field in json map to 'id' property in object mapper &lt;&lt;&lt; self.id &lt;-- "cat_id" // specify 'parent' field in json parse as following to 'parent' property in object mapper &lt;&lt;&lt; self.parent &lt;-- TransformOf&lt;(String, String), String&gt;(fromJSON: &#123; (rawString) -&gt; (String, String)? in if let parentNames = rawString?.characters.split(separator: "/").map(String.init) &#123; return (parentNames[0], parentNames[1]) &#125; return nil &#125;, toJSON: &#123; (tuple) -&gt; String? in if let _tuple = tuple &#123; return "\(_tuple.0)/\(_tuple.1)" &#125; return nil &#125;) &#125;&#125;let jsonString = "&#123;\"cat_id\":12345,\"name\":\"Kitty\",\"parent\":\"Tom/Lily\"&#125;"if let cat = Cat.deserialize(from: jsonString) &#123; print(cat.id) print(cat.parent)&#125; 排除指定属性如果在Model中存在因为某些原因不能实现HandyJSON协议的非基本字段，或者不能实现HandyJSONEnum协议的枚举字段，又或者说不希望反序列化影响某个字段，可以在mapping函数中将它排除。如果不这么做，可能会出现未定义的行为。 1234567891011121314151617181920212223class NotHandyJSONType &#123; var dummy: String?&#125;class Cat: HandyJSON &#123; var id: Int64! var name: String! var notHandyJSONTypeProperty: NotHandyJSONType? var basicTypeButNotWantedProperty: String? required init() &#123;&#125; func mapping(mapper: HelpingMapper) &#123; mapper &gt;&gt;&gt; self.notHandyJSONTypeProperty mapper &gt;&gt;&gt; self.basicTypeButNotWantedProperty &#125;&#125;let jsonString = "&#123;\"name\":\"cat\",\"id\":\"12345\"&#125;"if let cat = Cat.deserialize(from: jsonString) &#123; print(cat)&#125; 支持的属性类型 Int/Bool/Double/Float/String/NSNumber/NSString NSArray/NSDictionary Int8/Int16/Int32/Int64/UInt8/UInt16/UInt23/UInt64 Optional&lt;T&gt;/ImplicitUnwrappedOptional&lt;T&gt; // T is one of the above types Array&lt;T&gt; // T is one of the above types Dictionary&lt;String, T&gt; // T is one of the above types 以上类型的嵌套 序列化基本类型现在，序列化也要求Model声明服从HandyJSON协议。 12345678910111213141516class BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String! required init() &#123;&#125;&#125;let object = BasicTypes()object.int = 1object.doubleOptional = 1.1object.stringImplicitlyUnwrapped = “hello"print(object.toJSON()!) // serialize to dictionaryprint(object.toJSONString()!) // serialize to JSON stringprint(object.toJSONString(prettyPrint: true)!) // serialize to pretty JSON string 自定义映射和排除和反序列化一样，只要定义mapping和exclude就可以了。被排除的属性，序列化和反序列化都不再影响到它。而在mapping中定义的Transformer，同时定义了序列化和反序列的规则，所以只要为属性指明一个Transformer关系就可以了。 附加提供几个 JSON 字符串生成 model 类的工具： JSONExport iOS Code Generator D3Json JSONUtilities]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>model</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 tableViewCell高度自适应]]></title>
    <url>%2F2017%2F08%2F01%2F%E6%B5%85%E8%B0%88-tableViewCell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[UITableView 是开发中最常用到的控件,可以说没有哪个 APP 离得开 UITableView 控件,使用时难免会遇到各种各样的问题,其中 cell 高度自适应是最让人头疼的,简单说一下我在开发中总结.开发中面对 cell 的自适应有着各种各样的方法,无外乎以下几种: 根据数据源计算 通常做法为自定义 cell 添加类方法,传入当前 cell 的数据源,计算除 cell 的高度,返回.然后在 tableView 的代理方法中设置 cell 高度.这种方法计算 cell 高度是需要注意:但计算 label 的高度时,要留意 label 的宽度和字体大小的设置,否则将会得到错误的高度 调用 tableView 的代理方法,拿到 cell 获取高度 这种做法的缺点使cell 的生成代码重复执行. iOS 8.0 以后可以与新引入 cell 自适应方法(在 xib 下使用) 需要设置 rowHeight( = UITableViewAutomaticDimension) 与 estimatedRowHeight 两个属性, rowHeight 设置表明使用自适应, estimatedRowHeight 一个参考值.使用自适应如果 cell 中有图片,最好对 ImageView 的宽高进行限定,否则适配将会根据图片大小自适应.当加载图片张数不确定时,可以添加一个 View, 在给 cell 赋值时用代码添加 ImgView, 将 view 的高度约束拖成属性,在图片添加完成后修改 view 的高度.]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>cell 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 打包 framework]]></title>
    <url>%2F2017%2F07%2F25%2Fswift-%E6%89%93%E5%8C%85-framework%2F</url>
    <content type="text"><![CDATA[在开发中我们常常会用到一些第三方 SDK 库，使用时只需将 framework 文件添加到项目中即可，十分方便。同样地，我们也可以创建自己的 framework 框架，用来封装一些常用的工具方法、框架类等。一来不会使源代码完全暴露在外，二来也便于代码复用。 打包篇 新建项目 选择 File-&gt;New-&gt;Project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework, 点击 Next,语言选择 swift 如图: 创建完成生成以下目录: xxx.h 文件的作用是整个包对外提供的入口头文件，除了正常定义参数属性之外还提供 Swift项目内引用的OC文件的import引用 info.plist 文件的作用就如同正常项目的plist文件作用，用来定义或添加一些属性。 添加文件 可以新建文件也可以在已有项目拷贝这里要注意一下：由于打包类库工程不是一个完整项目工程，所以并没有AppDelegate等文件，所以涉及到这些的文件要额外处理，或改代码，或适当改变功能。注意：工程如果有桥接文件，是不能拷贝过来的，否则编译不通过。桥接文件下的 import 引用应该放到 xxx.h 文件中注意: 如果 swift 文件想要暴露给外部使用,类及方法要用 public 修饰 经过以上操作本库已基本完成 注意: 如果用到资源文件,如:图片,视频,音频等直接用Assets.xcassets是无效的,我们要新建文件夹,将图片放入其中,添加后缀名.bundle,例如 xxx.bundle,使用图片时图片名:xxx.bundle/icon.png. 文件添加完毕就可以尝试 build 一下了 正常情况下，如果我们swift项目引入了oc文件，我们必须通过一个桥接文件来处理两者之间的转换，而我们在新建类库包的时候，是禁止桥接文件存在的，即使你添加了，也会永远编译不过，打包不了。所以这里就用到这个 xxx.h 头文件了。我们可以通过这个文件来实现两者之间的转换，前提就是必须先将oc的.h暴露出来，否则即使你import，也会报错找不到.h 文件。 暴露文件给外部使用 选择 target-&gt;Build Phases-&gt;Header, 将要暴露给外部使用OC 的.h 的文件拖到 public 下,如果是 swift 只需要将类和方法声明成 public 编译通过，查看这里 红框内就是最终我们得到的Framework包。右击本地查看，会看到本类库以及对应的依赖第三方库包，后面在其他项目引用的时候，这些都是需要的（需要一起拷贝添加）。 合并真机和模拟器framework 包的分类编译得到的包可分为 debug 包和 release包, debug 包一般用于测试,如果要发布务必打 release 包.release 包又包含模拟器包和真机包,发布时需要将模拟器包与真机包合并去包文件夹 合并包终端输入 lipo -create 真机路径 模拟器路径 -output 真机路径（ps：这几个路径就是上图拖动到终端后的路径）但是并没有完，不知道为什么，终端这样合并只是假象，你需要手动去将Modules里的的 xxx.swiftmodule文件合并到一起 引用篇 新建空白工程 将之前所得到 framework 拷贝到项目 在工程Targets－General－EmbeddedBinaries内添加Frameworks包 附加 引用 CommonCrypto项目中用到了 MD5加密, swift 是无法调用 C语言库的,在 xxx.h 中添加#import 报错,解决方法:新建 module.modulemap 文件,在里边添加1234 module CommonCrypto [system] &#123; header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/CommonCrypto/CommonCrypto.h" export *&#125; 选择 target-&gt;Build Settings, 找到 swift compler-Search Paths, 在 Import paths 添加创建文件路径在需要 MD5机密的文件中 import CommonCrypto 参考博客 iOS打包framework - Swift完整项目打包Framework，嵌入OC项目使用iOS打包Framework真机和模拟器兼容合并版本 - 详细攻略步骤]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 网络请求]]></title>
    <url>%2F2017%2F07%2F18%2Fnetwork-swift%2F</url>
    <content type="text"><![CDATA[对 Alamofire与系统的网络请求进行简易封装 Alamofire post 请求1234567891011121314151617/// post 请求////// 服务器端返回数据为 JSON 数据格式/// - Parameters:/// - urlStr: 请求网络地址/// - params: 请求参数/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_post(_ urlStr: String, _ params: ayParams? = nil, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void)&#123; Alamofire.request(urlStr, method: .post, parameters: params, encoding: URLEncoding.default, headers: nil).responseJSON &#123; (response) in if response.result.isSuccess&#123; result(response.result.value!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error"); &#125; &#125;&#125; get 请求1234567891011121314151617/// get 请求////// 服务器端返回数据为 JSON 数据格式/// - Parameters:/// - urlStr: 请求网络地址/// - params: 请求参数/// - result: 请求成功返回数据/// - fail: 请求失败返回数据static func ay_get(_ urlStr: String, _ params: ayParams? = nil, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void)&#123; Alamofire.request(urlStr, method: .get, parameters: params, encoding: URLEncoding.default, headers: nil).responseJSON &#123; (response) in if response.result.isSuccess&#123; result(response.result.value!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error"); &#125; &#125;&#125; 下载文件12345678910111213141516171819202122232425/// 下载文件////// - Parameters:/// - urlStr: 文件地址/// - method: 请求方式/// - param: 请求参数/// - fileURL: 保存文件路径/// - progress: 下载进度/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_downloadFile(_ urlStr: String, _ method: HTTPMethod? = .get, _ param: ayParams? = nil, fileURL: URL, progress: @escaping (Progress)-&gt;Void, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void) &#123; //拼接文件保存地址 let destination: DownloadRequest.DownloadFileDestination = &#123; _, response in return (fileURL.appendingPathComponent(response.suggestedFilename!), [.removePreviousFile, .createIntermediateDirectories]) &#125; Alamofire.download(urlStr, method: method!, parameters: param, encoding: URLEncoding.default, headers: nil, to: destination).downloadProgress(queue: DispatchQueue.main, closure: &#123; (progres) in progress(progres) &#125;).responseData&#123;(response) in if response.result.isSuccess &#123; result(response.destinationURL!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error") &#125; &#125;&#125; 文件上传123456789101112131415161718192021222324252627282930313233343536/// 文件上传////// 上传文件时注意文件名与 mimeType/// - Parameters:/// - urlStr: 上传地址/// - param: 上传参数/// - filesData: 上传数据数组 data 类型/// - progress: 上传进度/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_uploadFile(_ urlStr: String, _ param:ayParams? = nil,filesData: [Data], progress:@escaping (Progress)-&gt;Void, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void) &#123; Alamofire.upload(multipartFormData: &#123; (formData) in for data:Data in filesData &#123; formData.append(data, withName: "file", fileName: "fileName.png", mimeType: "image/png") &#125; if param != nil &#123; for (key , value) in param! &#123; formData.append(value.data(using: String.Encoding.utf8)!, withName: key) &#125; &#125; &#125;, to: urlStr) &#123; (encodingResult) in switch encodingResult&#123; case .success(request: let upload,_,_): upload.uploadProgress(closure: &#123; (progres) in progress(progres) &#125;) upload.responseJSON(completionHandler: &#123; (response) in if let value = response.result.value as? [String : AnyObject]&#123; result(value) &#125; &#125;) case .failure(let error): fail(error.localizedDescription) &#125; &#125;&#125; 系统网络请求 post 请求12345678910111213141516171819202122232425262728293031/// post 请求////// - Parameters:/// - urlStr: 请求地址/// - params: 请求参数/// - result: 返回结果/// - fail: 失败class func post(_ urlStr: String, params: [String : String], result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; var request = URLRequest.init(url: URL(string: urlStr)!) request.timeoutInterval = NetworkConfig.timeoutInterval request.httpMethod = "POST" var paramStr = String() for (key , value) in params &#123; paramStr.append("\(key)=\(value)&amp;") &#125; paramStr.remove(at: paramStr.index(before: paramStr.endIndex)) request.httpBody = paramStr.data(using: .utf8) let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; get 请求123456789101112131415161718192021222324252627282930/// get 请求////// - Parameters:/// - urlStr: 请求地址/// - params: 请求参数/// - result: 返回结果/// - fail: 失败class func get(_ urlStr: String, params: [String : String], result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; var paramStr = String() for (key , value) in params &#123; paramStr.append("\(key)=\(value)&amp;") &#125; paramStr.remove(at: paramStr.index(before: paramStr.endIndex)) var request = URLRequest.init(url: URL(string: urlStr + "?" + paramStr)!) request.timeoutInterval = NetworkConfig.timeoutInterval request.httpMethod = "GET" let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 文件下载123456789101112131415161718192021222324/// 文件下载////// - Parameters:/// - urlStr: 下载地址/// - fileName: 文件名/// - result: 文件缓存路径/// - fail: 失败class func download(_ urlStr: String, fileName: String, result: @escaping (String) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; let request = URLRequest.init(url: URL(string: urlStr)!) let session = URLSession(configuration: NetworkConfig.configuration) let task = session.downloadTask(with: request) &#123; (pathUrl, response, error) in if error == nil &#123; if let filePath: String = pathUrl?.path &#123; let fileManager = FileManager() try! fileManager.moveItem(atPath: filePath, toPath: NetworkConfig.downloadPath.appending(fileName)) try! fileManager.removeItem(atPath: filePath) result(NetworkConfig.downloadPath.appending(fileName)) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 仿 form 表单多文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 仿 form 表单多文件上传////// - Parameters:/// - urlStr: 上传文件路径/// - params: 请求参数/// - filesData: 文件数据/// - fileName: 文件名/// - fileExtensions: 文件扩展名/// - contentType: 文件类型/// - result: 返回数据/// - fail: 失败class func upload(_ urlStr: String, params: [String : String], filesData: [Data], fileName: String, fileExtensions:String, contentType: String,result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; let boundary = "*****" // 分界标识 var bodyData = Data() // 添加普通参数 for (key , value) in params &#123; bodyData.append("\r\n--\(boundary)\r\n".data(using: .utf8)!) bodyData.append("Content-Disposition:form-data;name=\"\(key)\"\r\n".data(using: .utf8)!) bodyData.append("Content-Type:text/plain;charset=utf-8\r\n\r\n".data(using: .utf8)!) bodyData.append("\(value)".data(using: .utf8)!) &#125; // 添加文件数据 for i in 0 ..&lt; filesData.count &#123; bodyData.append("\r\n--\(boundary)\r\n".data(using: .utf8)!) bodyData.append("Content-Disposition:form-data; name=\"file\";filename=\(fileName)-\(i).\(fileExtensions)\r\n".data(using: .utf8)!) bodyData.append("Content-Type: \(contentType)\r\n\r\n".data(using: .utf8)!) bodyData.append(filesData[i]) &#125; bodyData.append("\r\n--\(boundary)--\r\n".data(using: .utf8)!) // 设置 request var request = URLRequest(url: URL(string: urlStr)!) request.addValue("multipart/form-data;boundary=\"\(boundary)\";charset=\"UTF-8\"", forHTTPHeaderField: "Content-Type") request.addValue("\(bodyData.count)", forHTTPHeaderField: "Content-Length") request.httpMethod = "POST" request.httpBody = bodyData request.timeoutInterval = NetworkConfig.timeoutInterval // 发起请求 let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 添加网络数据缓存类 简述 网络请求缓存处理 将网络请求结果保存在本地，发起网路请求时先检测缓存区是否有缓存数据并判断是否超出缓存有效时间，如果数据有效则加载缓存区数据，否则加载网络数据. 数据缓存采用 SQLite 存储，采用 FMDB 库. 缓存数据表表数据有 key,value,date 三个字段. key: 网络请求参数 MD5加密数据. value:网络请求数据. date: 数据有效时间 添加计时器,定时清除无效数据. 主要方法1234567891011121314151617181920212223/// 获取数据////// - Parameter key: 键值/// - Returns: 数据func getResult(_ key: String) -&gt; String?/// 添加数据////// - Parameters:/// - key: 键值/// - result: 请求数据/// - date: 有效时间func addResult(_ key: String, result: String, date: TimeInterval) -&gt; Void/// 移除失效数据////// - Parameter date: 时间点func removeResult(withOldDate date: TimeInterval) -&gt; Void/// 根据 key 移除数据////// - Parameter key: 键值func removeResult(_ key: String) -&gt; Void 具体实现参考 Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝微信简单封装]]></title>
    <url>%2F2017%2F07%2F14%2FPayDemo%2F</url>
    <content type="text"><![CDATA[封装支付宝与微信支付,采用代理的方式接收支付结果. 支付宝支付 调起支付12345678/// 调起支付宝支付////// - Parameters:/// - orderinfo: 商品信息字符串/// - signedString: 商户信息签名/// - fromScheme: 应用注册scheme/// - resultDic: 支付结果回调func pay(_ orderinfo: String, signedString: String, fromScheme: String) -&gt; Void 支付结果回调,遵守 AlipayDelegate 协议12345678/// 支付成功func alipaySuccess(_ result: Any) -&gt; Void;/// 支付失败func alipayFail(_ result: Any) -&gt; Void;/// 支付取消func alipayCancel(_ result: Any) -&gt; Void;/// 其他未知错误func alipayUnknownError(_ result: Any) -&gt; Void; 微信支付 调起支付1234/// 微信支付////// - Parameter orderInfo: 支付信息(包含:partnerId,prepayId,package,nonceStr,timeStamp,sign等信息)func pay(_ orderInfo: [String : String]) -&gt; Void 微信支付 item appid: 应用ID(微信开放平台审核通过的应用APPID) partnerid: 商户号(微信支付分配的商户号) prepayid: 预支付交易会话ID(微信返回的支付交易会话ID) package: 扩展字段(只读) noncestr： 随机字符串（只读） timestamp： 时间撮（只读） getSignDic()： 获取签名后的字典 数据签名(获取签名字符串)1234567/// 获取签名字符串(MD5 签名)////// - Parameters:/// - orderInfo: 支付信息/// - keyStr: API密钥/// - Returns: 签名字符串func getSignStr(_ orderInfo: [String : String] ,keyStr: String) -&gt; String 支付结果回调,遵守 WeChatPayDelegate 协议12345678/// 微信未安装func WeChatPayWXAppUninstall() -&gt; Void;/// 支付成功func WeChatPaySuccess() -&gt; Void;/// 支付失败func WeChatPayFail(errStr: String) -&gt; Void;/// 支付取消func WeChatPayCancel() -&gt; Void; 具体实现参考 Demo]]></content>
      <categories>
        <category>iOS</category>
        <category>三方接入</category>
      </categories>
      <tags>
        <tag>pay</tag>
        <tag>alipay</tag>
        <tag>wechatpay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[swift] 星级评分]]></title>
    <url>%2F2017%2F07%2F13%2Fswift-%E6%98%9F%E7%BA%A7%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[许多App都会有评价功能，这个时候或许会需要实现星级评分，下面我们来简单的实现一个星级评分功能。 思路 通过添加图片形式实现星级打分功能.创建两个视图,其中一个添加灰色星星图片,另一个添加橘色星星图片.橘色星星视图覆盖灰色星星视图,通过修改橘色星星视图的宽度实现评分的展现. 创建一个继承于 UIView 的类,作为星级打分的显示视图 创建灰色星星视图,并添加到父视图. 创建橘色星星视图,添加到父视图,保证橘色视图覆盖灰色星星视图. 通过修改橘色星星视图宽度实现评分. 可通过手势等方式实现打分功能. 主要代码创建子视图代码:1234567891011121314private func ay_creatStartView(_ imageName: String) -&gt; UIView &#123; let starView = UIView(frame: CGRect(x: 0, y: 0, width: self.frame.width, height: self.frame.height)) starView.clipsToBounds = true starView.backgroundColor = UIColor.clear starView.isUserInteractionEnabled = false let imgViewWidth = (self.frame.width - CGFloat(totalStarNumber - 1) * 3) / CGFloat(totalStarNumber) for i in 0 ..&lt; totalStarNumber &#123; let imageView = UIImageView(image: UIImage(named: imageName)) imageView.frame = CGRect(x: CGFloat(i) * (imgViewWidth + 3), y: 0, width: imgViewWidth, height: self.frame.height) imageView.contentMode = .scaleAspectFit starView.addSubview(imageView) &#125; return starView &#125; 手指滑动打分代码123456789101112131415override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first let point = touch?.location(in: self) if (point?.x)! &gt;= CGFloat(0) &amp;&amp; (point?.x)! &lt;= self.frame.width &#123; rate = (point?.x)! / self.frame.width delegate?.ay_starRateChange(rate: rate) &#125; &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first let point = touch?.location(in: self) rate = (point?.x)! / self.frame.width delegate?.ay_starRateChange(rate: rate) &#125; 具体实现参考Demo 附加星级评分通过图片实现是最简单的办法,当然也可以通过其他方式实现.例如通过 UIBezierPath 绘制,具体可参考CPSliderView]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>自定义视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 UIBezierPath 与 CAShapeLayer 为 UIView 添加边框]]></title>
    <url>%2F2017%2F07%2F12%2F%E9%80%9A%E8%BF%87-CGMutablePath-%E4%B8%BA-UIView-%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[通过贝塞尔曲线与 CAShapeLayer 为 View 添加虚线边框,可设置宽度,颜色,圆角等 代码如下: 123456789101112131415161718192021222324252627282930313233/// 为视图添加虚线边框 /// /// - Parameters: /// - view: 要添加边框的视图 /// - size: 视图 size /// - cornerRadius: 视图圆角 默认:10 /// - lineWidth: 边框宽 默认: 1 /// - lineColor: 边框颜色 默认: black /// - lineDashPattern: 边框段长和间距 默认: [5,3] func addBorderLine(view:UIView, size:CGSize, cornerRadius:CGFloat = 10, lineWidth:CGFloat = 1, lineColor:Color? = Color.black, lineDashPattern: [NSNumber] = [5,3]) -&gt; Void &#123; let shaplayer = CAShapeLayer() shaplayer.bounds = CGRect.init(x: 0, y: 0, width: size.width, height: size.height) shaplayer.anchorPoint = CGPoint.init(x: 0, y: 0) shaplayer.fillColor = Color.clear.cgColor shaplayer.strokeColor = lineColor?.cgColor shaplayer.lineWidth = lineWidth shaplayer.lineJoin = "miter" shaplayer.lineDashPattern = [5,3] let path = CGMutablePath() path.move(to: CGPoint.init(x: lineWidth / 2, y: cornerRadius + lineWidth / 2)) path.addArc(center: CGPoint.init(x: cornerRadius + lineWidth / 2, y: cornerRadius + lineWidth / 2), radius: cornerRadius, startAngle: .pi, endAngle: .pi / 2 * 3, clockwise: false) path.addLine(to: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: lineWidth / 2)) path.addArc(center: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: cornerRadius + lineWidth / 2), radius: cornerRadius, startAngle: .pi / 2 * 3, endAngle: .pi * 2, clockwise: false) path.addLine(to: CGPoint.init(x: size.width - lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2)) path.addArc(center: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2), radius: cornerRadius, startAngle: 0, endAngle: .pi / 2, clockwise: false) path.addLine(to: CGPoint.init(x: cornerRadius + lineWidth / 2, y: size.height - lineWidth / 2)) path.addArc(center: CGPoint.init(x: cornerRadius + lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2), radius: cornerRadius, startAngle: .pi / 2, endAngle: .pi, clockwise: false) path.addLine(to: CGPoint.init(x: lineWidth / 2, y: cornerRadius + lineWidth / 2)) shaplayer.path = path view.layer.addSublayer(shaplayer) view.layer.masksToBounds = true view.layer.cornerRadius = cornerRadius &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>UIBezierPath</tag>
        <tag>CAShapeLayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常阅读的博客]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%B8%B8%E9%98%85%E8%AF%BB%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我要申明，排名不分前后 iOSObjC 中国 bang’s blog 唐巧的技术博客 蘑菇街李忠 雷纯锋的技术博客 Sergio Chan 自己的博客 casa 的博客 冰霜的博客 串神的博客 南栀的博客 卓同学的博客 判若两人丶的博客 draveness 的博客 Other廖雪峰的官方网站 pandar’s blog]]></content>
      <categories>
        <category>Other</category>
        <category>阅读列表</category>
      </categories>
      <tags>
        <tag>Other</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
