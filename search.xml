<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 实现电子签名]]></title>
    <url>%2F2019%2F08%2F07%2FiOS%20%E5%AE%9E%E7%8E%B0%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[实现原理 使用拖动手势记录获取用户签名路径. 当用户初次接触屏幕,生成一个新的UIBezierPath,并加入数组中.设置接触点为起点.在手指拖动过程中为UIBezierPath添加线条,并重新绘制,生成连续的线. 手指滑动中不断的重新绘制,形成签名效果. 签名完成,转化为UIImage保存.实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class CXGSignView: UIView &#123; var path: UIBezierPath? var pathArray: [UIBezierPath] = [] override init(frame: CGRect) &#123; super.init(frame: frame) self.backgroundColor = UIColor.gray setupSubviews() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125; func setupSubviews() &#123; let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(panGestureRecognizerAction(_:))) self.addGestureRecognizer(panGestureRecognizer) &#125; @objc func panGestureRecognizerAction(_ sender: UIPanGestureRecognizer) &#123; // 获取当前点 let currentPoint = sender.location(in: self) if sender.state == .began &#123; self.path = UIBezierPath() path?.lineWidth = 2 path?.move(to: currentPoint) pathArray.append(path!) &#125;else if sender.state == .changed &#123; path?.addLine(to: currentPoint) &#125; self.setNeedsDisplay() &#125; // 根据 UIBezierPath 重新绘制 override func draw(_ rect: CGRect) &#123; for path in pathArray &#123; // 签名颜色 UIColor.black.set() path.stroke() &#125; &#125; // 清空 func clearSign() &#123; pathArray.removeAll() self.setNeedsDisplay() &#125; // 撤销 func undoSign() &#123; guard pathArray.count &gt; 0 else &#123; return &#125; pathArray.removeLast() self.setNeedsDisplay() &#125; /// 签名转化为图片 func saveSignToImage() -&gt; UIImage? &#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, UIScreen.main.scale) guard let context = UIGraphicsGetCurrentContext() else &#123; return nil &#125; self.layer.render(in: context) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>UIBezierPath</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Alamofire 的文件下载功能实现]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%9F%BA%E4%BA%8E%20Alamofire%20%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实现下载的流程 实现方法查看 CXGDownloadTools.swift st=>start: 开始 e=>end: 结束 input=>inputoutput: 输入下载地址,参数 rePath=>operation: 返回文件保存路径 checkPath=>condition: 是否存在文件 checkResumeData=>condition: 是否存在下载记录文件 resumDownload=>operation: 继续下载 newDownload=>operation: 开始下载 checkDownload=>condition: 是否下载成功 saveResumData=>operation: 保存下载信息 st->input->checkPath checkPath(yes,right)->rePath->e checkPath(no)->checkResumeData checkResumeData(yes,right)->resumDownload->checkDownload checkResumeData(no)->newDownload->checkDownload checkDownload(yes)->rePath->e checkDownload(no,right)->saveResumData->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>iOS</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Alamofire</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会旋转的 UIImageView]]></title>
    <url>%2F2019%2F07%2F09%2F%E4%BC%9A%E6%97%8B%E8%BD%AC%E7%9A%84%20UIImageView%2F</url>
    <content type="text"><![CDATA[主要提供三个方法: startRotating, stopRotating,resumeRotate startRotating 1234567891011/// 开始动画func startRotating() &#123; let rotateAnimation = CABasicAnimation(keyPath: "transform.rotation") rotateAnimation.isRemovedOnCompletion = false // 避免点击 Home 键返回,动画停止 rotateAnimation.fromValue = 0.0 rotateAnimation.toValue = Double.pi * 2 rotateAnimation.duration = 20 rotateAnimation.repeatCount = MAXFLOAT self.layer.add(rotateAnimation, forKey: nil) isRotating = true&#125; stopRotating 123456789101112/// 停止动画func stopRotating() &#123; if !isRotating &#123; return &#125; let pausedTime = self.layer.convertTime(CACurrentMediaTime(), from: nil) // 让CALayer的时间停止走动 self.layer.speed = 0 // 让CALayer的时间停留在pausedTime这个时刻 self.layer.timeOffset = pausedTime isRotating = false&#125; resumeRotate 1234567891011121314151617181920212223242526/// 继续动画func resumeRotate() &#123; if isRotating &#123; return &#125; if self.layer.timeOffset == 0 &#123; startRotating() return &#125; let pausedTime = self.layer.timeOffset // 1. 让CALayer的时间继续行走 self.layer.speed = 1.0 // 2. 取消上次记录的停留时刻 self.layer.timeOffset = 0.01 // 3. 取消上次设置的时间 self.layer.beginTime = 0.0 // 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime) let timeWhenpause = self.layer.convertTime(CACurrentMediaTime(), from: nil) - pausedTime // 5. 设置相对于父坐标系的开始时间(往后退timeSincePause) self.layer.beginTime = timeWhenpause isRotating = true&#125; 注意: 使用中发现,当点下 Home 键再次返回应用时,图片停止转动,需要将动画 isRemovedOnCompletion 置成 false. 参考代码]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>CABasicAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keychain的介绍和使用]]></title>
    <url>%2F2019%2F06%2F03%2FKeychain%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是 Keychain? iOS 的 keychain 服务提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，每个ios程序都有一个独立的keychain存储。用于储存一些私密信息，比如密码、证书等等，Keychain里保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效。同样也适用于应用之间数据共享。我们可以把KeyChain理解为一个Dictionary，所有数据都以key-value的形式存储，可以对这个Dictionary进行add、update、get、delete这四个操作。 keychain 的四个方法介绍?存储方法1OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef * __nullable CF_RETURNS_RETAINED result) attributes: 要添加的数据result: 存储数据后,返回一个指向该数据的引用,不使用该数据传入 nil 条件查询方法1OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef * __nullable CF_RETURNS_RETAINED result) query: 要查询数据的条件result: 查询到数据的引用 数据更新方法1OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate) query: 要更新数据的查询条件attributesToUpdate: 要更新的数据 删除数据方法1OSStatus SecItemDelete(CFDictionaryRef query) query: 要删除数据的查询条件 使用 Keychain 使用 Keychain 首先需要导入安全框架 secutity.framework 创建查询条件12345678910111213class func createQuaryMutableDictionary(identifier: String)-&gt;NSMutableDictionary&#123; // 创建一个条件字典 let keychainQuaryMutableDictionary = NSMutableDictionary.init(capacity: 0) // 设置条件存储的类型 keychainQuaryMutableDictionary.setValue(kSecClassGenericPassword, forKey: kSecClass as String) // 设置存储数据的标记 keychainQuaryMutableDictionary.setValue(identifier, forKey: kSecAttrService as String) keychainQuaryMutableDictionary.setValue(identifier, forKey: kSecAttrAccount as String) // 设置数据访问属性 keychainQuaryMutableDictionary.setValue(kSecAttrAccessibleAfterFirstUnlock, forKey: kSecAttrAccessible as String) // 返回创建条件字典 return keychainQuaryMutableDictionary&#125; 存储数据1234567891011121314class func keyChainSaveData(data: Any ,withIdentifier identifier:String)-&gt; Bool &#123; // 获取存储数据的条件 let keyChainSaveMutableDictionary = self.createQuaryMutableDictionary(identifier: identifier) // 删除旧的存储数据 SecItemDelete(keyChainSaveMutableDictionary) // 设置数据 keyChainSaveMutableDictionary.setValue(NSKeyedArchiver.archivedData(withRootObject: data), forKey: kSecValueData as String) // 进行存储数据 let saveState = SecItemAdd(keyChainSaveMutableDictionary, nil) if saveState == noErr &#123; return true &#125; return false&#125; 更新数据1234567891011121314class func keyChainUpdata(data: Any ,withIdentifier identifier:String)-&gt;Bool &#123; // 获取更新的条件 let keyChainUpdataMutableDictionary = self.createQuaryMutableDictionary(identifier: identifier) // 创建数据存储字典 let updataMutableDictionary = NSMutableDictionary.init(capacity: 0) // 设置数据 updataMutableDictionary.setValue(NSKeyedArchiver.archivedData(withRootObject: data), forKey: kSecValueData as String) // 更新数据 let updataStatus = SecItemUpdate(keyChainUpdataMutableDictionary, updataMutableDictionary) if updataStatus == noErr &#123; return true &#125; return false&#125; 查询数据123456789101112131415161718class func keyChainReadData(identifier: String)-&gt; Any &#123; var idObject:Any? // 获取查询条件 let keyChainReadmutableDictionary = self.createQuaryMutableDictionary(identifier: identifier) // 提供查询数据的两个必要参数 keyChainReadmutableDictionary.setValue(kCFBooleanTrue, forKey: kSecReturnData as String) keyChainReadmutableDictionary.setValue(kSecMatchLimitOne, forKey: kSecMatchLimit as String) // 创建获取数据的引用 var queryResult: AnyObject? // 通过查询是否存储在数据 let readStatus = withUnsafeMutablePointer(to: &amp;queryResult) &#123; SecItemCopyMatching(keyChainReadmutableDictionary, UnsafeMutablePointer($0))&#125; if readStatus == errSecSuccess &#123; if let data = queryResult as! NSData? &#123; idObject = NSKeyedUnarchiver.unarchiveObject(with: data as Data) as Any &#125; &#125; return idObject as Any&#125; 删除数据123456class func keyChianDelete(identifier: String)-&gt;Void&#123; // 获取删除的条件 let keyChainDeleteMutableDictionary = self.createQuaryMutableDictionary(identifier: identifier) // 删除数据 SecItemDelete(keyChainDeleteMutableDictionary)&#125; 简单应用获取 UUID 直接获取 UUID 每次卸载重新安装 app 后可能会导致 UUID 变化,为了获取唯一的 UUID,我们使用 keyChian 对 UUID 进行保存123456789101112class func getUUID() -&gt; String &#123; if let uuid = QWUUIDTools.keyChainReadData(identifier: "key") as? String &#123; return uuid &#125;else &#123; if let uuid = UIDevice.current.identifierForVendor?.uuidString &#123; if QWUUIDTools.keyChainSaveData(data: uuid, withIdentifier: "key") &#123; return uuid &#125; &#125; &#125; return "simulator"&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>keychain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次树形分级列表的实现]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%A0%91%E5%BD%A2%E5%88%86%E7%BA%A7%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实现思路使用 tableView 实现先树形结构(不同的 cell 样式显示不同的等级),当点击 cell 时,判断当前点击的 cell 是否存在下一级,是否已经是打开状态.如果存在下一级,关闭状态,则通过插入 cell 实现点击展开树形图的效果.如果存在下一级且已经展开则通过删除 cell的方式实现树形图的关闭效果. 具体实现 定义数据结构类型,如下: 12345678910111213141516171819class YTTTreeListModel: NSObject &#123; /** 你所需要的属性 var name: String = "" var address: String = "" var age: Int = -1 ... **/ // 当前节点是否有下一级 var isShow: Bool = false // 当前节点是否展开 var isOpen: Bool = false // 当前的等级 var level: Int = 0 // 当前节点的子节点 var child: [QWMyTeamModel] = []&#125; 定义主要的方法(递归算法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// 获取 cell 的行数////// - Parameter items: 数据源/// - Returns: cell 行数private func getRowsNum(_ items: [YTTTreeListModel]) -&gt; Int &#123; var num = 0 items.forEach &#123; (model) in num += 1 if model.isShow &amp;&amp; model.isOpen &amp;&amp; model.child.count &gt; 0 &#123; num += getRowsNum(model.child) &#125; &#125; return num&#125;/// 获取当前 cell 的数据模型////// - Parameters:/// - items: 数据源/// - index: 当前位置/// - Returns: 数据模型private func getItem(_ items: [YTTTreeListModel], index: inout Int) -&gt; YTTTreeListModel? &#123; for item in items &#123; if index == 0 &#123; return item &#125; index -= 1 if item.isShow &amp;&amp; item.isOpen &amp;&amp; item.child.count &gt; 0 &#123; if let model = getItem(item.child, index: &amp;index) &#123; return model &#125; &#125; &#125; return nil&#125;/// 获取需要添加或删除的 cell////// - Parameters:/// - item: 当前数据模型(点击的 cell)/// - index: 当前位置/// - Returns: 需要删除或添加位置private func getIndexPath(_ item: YTTTreeListModel, index: inout Int) -&gt; [IndexPath] &#123; var indexPaths: [IndexPath] = [] for item in item.child &#123; index += 1 indexPaths.append(IndexPath(row: index, section: 0)) if item.isShow &amp;&amp; item.isOpen &amp;&amp; item.child.count &gt; 0 &#123; indexPaths.append(contentsOf: getIndexPath(item, index: &amp;index)) &#125; &#125; return indexPaths&#125; 实现代理方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// dataArr private var dataArr: [YTTTreeListModel] = []func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return getRowsNum(dataArr) &#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; var index = indexPath.row if let model = getItem(dataArr, index: &amp;index) &#123; if model.level == 1 &#123; // 返回第一级样式 &#125; else if model.level == 2 &#123; // 返回第二级样式 &#125;else if model.level == 3 &#123; // 返回第三级样式 &#125; ... &#125; return UITableViewCell()&#125;func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; var index = indexPath.row if let model = getItem(dataArr, index: &amp;index) &#123; if model.isOpen &#123; tableView.beginUpdates() model.isOpen = false var ind = indexPath.row tableView.reloadRows(at: [indexPath], with: .none) tableView.deleteRows(at: getIndexPath(model, index: &amp;ind), with: .none) tableView.endUpdates() &#125;else &#123; if !model.isShow &#123; return &#125; // 存在下一级且子级已经加载直接展开 if model.isShow == 1 &amp;&amp; model.child.count &gt; 0 &#123; tableView.beginUpdates() model.isOpen = true var ind = indexPath.row tableView.reloadRows(at: [indexPath], with: .none) tableView.insertRows(at: getIndexPath(model, index: &amp;ind), with: .none) tableView.endUpdates() &#125;else &#123; // 存在下一级,但数据未请 求网络请求 http.globalPOST(url: **, parameters: ["": ""], success: &#123; [weak self] (result) in if let models = YTTTreeListModel(dictArray: result) as? [YTTTreeListModel] &#123; model.child = models.compactMap(&#123; (item) -&gt; YTTTreeListModel in item.level = model.level + 1 // 设置等级 return item &#125;) tableView.beginUpdates() model.isOpen = true var ind = indexPath.row tableView.reloadRows(at: [indexPath], with: .none) if let indexs = self?.getIndexPath(model, index: &amp;ind) &#123; tableView.insertRows(at: indexs, with: .none) &#125; tableView.endUpdates() &#125; &#125;, fail: &#123;(error) in &#125;, isHUD: true) &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>树形</tag>
        <tag>tableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView 在 iOS10 系统下显示不完全问题]]></title>
    <url>%2F2019%2F03%2F27%2FWKWebView%E5%9C%A8iOS10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[WKWebView与 UIWebView 比较 UIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度也有提升，但是并不像内存那样提升那么多。 WKWebView 优势: 更多的支持HTML5的特性 官方宣称的高达60fps的滚动刷新率以及内置手势 Safari相同的JavaScript引擎 将UIWebViewDelegate与UIWebView拆分成了14类与3个协议(官方文档说明) 另外用的比较多的，增加加载进度属性：estimatedProgress WKWebView 使用 WKWebView 使用遇到问题 在开发中为了提高加载速度,使用 WKWebView 替换了 UIWebView, 在 iOS8,iOS9,iOS11系统下均未发现问题,在 iOS10系统系下出现显示不完全问题.具体应用是在 UITableViewCell 中添加了 WKWebView,发现 WKWebView 无法完全显示,有大片空白存在,通过查询资料得知是由于 render 渲染问题,根据网上说明进行了修改:123456789// in the UITableViewDelegatefunc scrollViewDidScroll(scrollView: UIScrollView) &#123; if let tableView = scrollView as? UITableView &#123; for cell in tableView.visibleCells &#123; guard let cell = cell as? MyCustomCellClass else &#123; continue &#125; cell.webView?.setNeedsLayout() &#125; &#125;&#125; WKWebView 高度自适应 为了用户体验,我们需要 WKWebView 根据网页数据进行高度自适应,通过 WKWebView 的 WKNavigationDelegate 代理实现:1234567891011121314151617181920212223// in the WKNavigationDelegatefunc webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; // 处理网页图片过大问题 let js = """ function imgAutoFit() &#123; var imgs = document.getElementsByTagName('img'); for (var i = 0; i &lt; imgs.length; ++i) &#123; var img = imgs[i]; img.style.maxWidth = \(kScreenWidth - 20); &#125; &#125; """ webView.evaluateJavaScript(js, completionHandler: nil) webView.evaluateJavaScript("imgAutoFit()", completionHandler: nil) // 获取网页高度 webView.evaluateJavaScript("document.body.scrollHeight") &#123; (obj, error) in if let height = obj as? CGFloat &#123; // height 网页数据高度 &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView性能优化]]></title>
    <url>%2F2019%2F02%2F21%2FUITableView%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[提前计算并缓存好高度，因为heightForRow最频繁的调用。 - (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath; 异步绘制，遇到复杂界面，性能瓶颈时，可能是突破口。 滑动时按需加载，这个在大量图片展示，网络加载时，很管用。（SDWebImage已经实现异步加载）。 重用cells。 如果cell内显示得内容来自web，使用异步加载，缓存结果请求。当cell中的部分View是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些view缓存起来。当然也是缓存在模型中。 少用或不用透明图层，使用不透明视图。对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制） 减少subViews。分析Cell结构，尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的 少用addView给cell动态添加view，可以初始化的时候就添加，然后通过hide控制是否显示。只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消除 UINavigationBar 底部黑线]]></title>
    <url>%2F2018%2F12%2F18%2Fswift%20%E6%B6%88%E9%99%A4%20UINavigationBar%20%E5%BA%95%E9%83%A8%E9%BB%91%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[1. 通过设置背景图片与阴影图片清除123// 在自定义 UINavigationController 内self.navigationBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default)self.navigationBar.shadowImage = UIImage() 2. 通过遍历 UINavigationBar 子视图,找到对应的 View,设置为隐藏1234567891011121314151617181920212223extension UINavigationBar &#123; func hideBottomHairline() &#123; findUnderImageView(self)?.isHidden = true &#125; func showBottomHairline() &#123; findUnderImageView(self)?.isHidden = true &#125; func findUnderImageView(_ view: UIView) -&gt; UIImageView? &#123; if view is UIImageView &amp;&amp; view.bounds.height &lt;= 1.0 &#123; return view as? UIImageView &#125; for subView in view.subviews &#123; return self.findUnderImageView(subView) &#125; return nil &#125;&#125; 使用时只需在 viewWillAppear 方法中添加 self.navigationController?.navigationBar.hideBottomHairline()]]></content>
      <categories>
        <category>iOS</category>
        <category>导航栏</category>
      </categories>
      <tags>
        <tag>UINavigationBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 源码一览]]></title>
    <url>%2F2018%2F11%2F20%2FSDWebImage%20%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[SDImageCacheSDMemoryCache (只针对 iOS, 其他系统与 NSCache 一样)SDMemoryCache: 继承于NSCache. 声明三个私有属性: config, weakCache, weakCacheLock config: SDImageCacheConfig 缓存配置信息 weakCache: NSMapTable 缓存信息 weakCacheLock: dispatch_semaphore_t 锁,保证数据安全 123456789101112131415161718/// 初始化 config, weakCache, weakCacheLock 变量, 添加一个内存警告监听, 内存警告时释放内存.- (instancetype)initWithConfig:(SDImageCacheConfig *)config// shouldUseWeakMemoryCache: 为 true 是将数保存到 weakCache, 反之不保存到 weakCache;获取是为 flase 是直接返回父类查出数据. 反之判断内存中是否有对应数据,没有再在 weakCache 获取,并保存到内存./// 保存数据 重写父类方法,首先将数据保存内存,然后再将数据存储在 weakCache.(weakCacheLock保证数据安全)/// 如果 shouldUseWeakMemoryCache 为 false 则不存储到 weakCache.- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g/// 获取数据 重写父类方法. 判断是否是弱内存缓存,否: 直接返回父类查询对象.是: 在 weakCache 取出相应对象并保存内存中返回.- (id)objectForKey:(id)key/// 根据 key 移除数据 重写父类方法. 如果 shouldUseWeakMemoryCache 为 false 只移除内存数据,为 true 移除 weakCache.- (void)removeObjectForKey:(id)key/// 移除数据 重写父类方法. 如果 shouldUseWeakMemoryCache 为 false 只移除内存数据,为 true 移除 weakCache.- (void)removeAllObjects SDImageCache SDImageCache: 图片缓存类 memCache: SDMemoryCache 内存控制器 diskCachePath: NSString 根路径 customPaths: NSMutableArray 自定义路径 只读路径 ioQueue: dispatch_queue_t 数据读取队列 fileManager: NSFileManager 文件管理器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// 提供单例方式创建+ (nonnull instancetype)sharedImageCache/// 给属性复制初始化. 默认为 NSCachesDirectory 下路径. 添加两个通知 删除旧数据- (nonnull instancetype)initWithNamespace:(nonnull NSString *)nsdiskCacheDirectory:(nonnull NSString *)directory/// 省略一系列文件路径处理方法.../// 对 key MD5加密处理产生文件名- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key/** 缓存数据 self.config.shouldCacheImagesInMemory 为true 则保存内存,否则只保存磁盘 @param image 图片 @param imageData 图片 Data @param key 键值 @param toDisk 是否存磁盘 @param completionBlock 存储回调 */- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock// 保存文件.通过写文件形式保存. self.config.shouldDisableiCloud 为 true 保存 iCloud- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key // 判断是否有缓存文件存在- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock// 获取存储的数据- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key// 仅在内存查找缓存 - (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key// 在磁盘查找缓存 diskImage &amp;&amp; self.config.shouldCacheImagesInMemory 为 true 写入内存- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key// 缓存查找 先查找内存,然后磁盘- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock// 移除缓存 (内存与磁盘)- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion UIImageView 加载图片UIImageView+WebCacheUIImageView 类扩展, 添加方法12345678910/** UIImageView+WebCache 添加的方法最终都调用该方法. @param url 图片 URL 地址 @param placeholder 占位图片 @param options 加载模式 @param progressBlock 进度 @param completedBlock 加载完成回调*/- (void)sd_setImageWithURL:(nullable NSURL *)url laceholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock UIView+WebCacheUIImageView,UIButton 等添加的类目方法将调用该扩展方法.123456789101112131415/** * 该方法采用了大量的回调函数. * 1. 判断当前图片是否在加载,如果在加载取消加载. * 2. 设置占位图现在. * 3. 判断 URL 是否有效,无效调用 completedBlock 返回 * 4. 初始化 SDWebImageManager 对象 * 5. 调用 SDWebImageManager 图片加载方法. * 6. SDWebImageManager 回调中处理. * 6.1. 当前对象已销毁或者回调图片 URL 与需要加载不一致,返回 * 6.2. 判断是否需要更新显示图片.调用 callCompletedBlockClojure 代码. * 6.3. 需要更新图片 调用图片更换方法 * 6.4. 将 SDWebImageOperation 添加到 SDOperationsDictionary */ - (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options operationKey:(nullable NSString *)operationKey setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock context:(nullable NSDictionary&lt;NSString *, id&gt; *)context SDWebImageManager图片缓存查找以及下载处理1234567/** * 1. 创建 SDWebImageCombinedOperation * 2. 判断 URL 是否有效.无效直接返回 * 3. 将 operation 加入到 runningOperations * 4. 调用 SDImageCache 中方法查找是否有缓存数据,如果找到回调 移除 Operation * 5. 找不到用 SDWebImageDownloader 下载图片.并保存缓存中.- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock]]></content>
      <categories>
        <category>iOS</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>三方库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁止 UIButton 连续点击]]></title>
    <url>%2F2018%2F09%2F10%2Fswift%20%E7%A6%81%E6%AD%A2%20UIButton%20%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB%2F</url>
    <content type="text"><![CDATA[UIButton是我们iOS开发中常用的控件，连续／抖动点击造成数据请求或其它操作重复执行也是用户使用中常发生的 !解决这一问题的方法很多,简单总结了一下. 使用UIButton的enabled或userInteractionEnabled使用UIButton的enabled属性,点击后将enabled设置为 false, 进行任务处理,完成任务后再将其设置为 false.1234567@objc func btnClick(_ sender: UIButton) &#123; sender.isEnabled = false // 网络请求 // 数据处理 // .... sender.isEnabled = true &#125; runtime 对 sendAction:to:forEvent: 进行处理添加 UIButton 的分类,在其分类进行处理,对全局 UIButton 有效自定义 yttsendAction( action: to:, for event:) 方法,对点击进行处理,利用 runtime 进行方法交换.swift 取消了 load 方法,具体实现方法交换参考swift下使用runtime交换方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private var UIButton_acceptEventTime: Void?private var UIButton_acceptInterval: Void?extension UIButton: YTTExtensionProtocol &#123; static func awake() &#123; if let oldMethod = class_getInstanceMethod(self, #selector(sendAction(_:to:for:))), let newMethod = class_getInstanceMethod(self, #selector(ytt_sendAction(_:to:for:))) &#123; method_exchangeImplementations(oldMethod, newMethod) &#125; &#125; // 连续点击时间间隔 var acceptEventInterval: TimeInterval &#123; get &#123; if let time = objc_getAssociatedObject(self, &amp;UIButton_acceptInterval) as? TimeInterval &#123; return time &#125; else &#123; objc_setAssociatedObject(self, &amp;UIButton_acceptInterval, 1, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) return 1 &#125; &#125; set &#123; objc_setAssociatedObject(self, &amp;UIButton_acceptInterval, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125; // 上次点击时间 private var acceptEventTime: TimeInterval &#123; get &#123; if let time = objc_getAssociatedObject(self, &amp;UIButton_acceptEventTime) as? TimeInterval &#123; return time &#125; else &#123; objc_setAssociatedObject(self, &amp;UIButton_acceptEventTime, 0, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) return 0 &#125; &#125; set &#123; objc_setAssociatedObject(self, &amp;UIButton_acceptEventTime, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125; @objc func ytt_sendAction(_ action: Selector, to target: Any?, for event: UIEvent?) &#123; if Date().timeIntervalSince1970 - self.acceptEventTime &gt;= acceptEventInterval &#123; self.ytt_sendAction(action, to: target, for: event) acceptEventTime = Date().timeIntervalSince1970 &#125; &#125;&#125; 下载文件UIButton+YTT,将两个文件拖入到工程,添加 AppDelegate 扩展:1234567891011extension UIApplication &#123; private static let runOnce: Void = &#123; YTTExtensionManager.harmlessFunction() &#125;() override open var next: UIResponder? &#123; // Called before applicationDidFinishLaunching UIApplication.runOnce return super.next &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带复制功能的 Label]]></title>
    <url>%2F2018%2F08%2F30%2Fswift%20%E5%B8%A6%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E7%9A%84%20Label%2F</url>
    <content type="text"><![CDATA[产品需求需要对 UILabel 展示的文本进行复制操作,针对这一需求想出了两种实现方式: 1.自定义控件,添加复制功能. 2.使用 UItextView 实现. 通过自定义 UILabel 的子类实现 创建 YTTCopyLabel, 使其继承于 UILabel. 12class YTTCopyLabel: UILabel &#123;&#125; 使 YTTCopyLabel 可以进行交互, 添加长按手势使其触发复制事件 123456789101112131415161718override var canBecomeFirstResponder: Bool &#123; return true &#125;override func awakeFromNib() &#123; super.awakeFromNib() setup()&#125;override init(frame: CGRect) &#123; super.init(frame: frame) setup()&#125;private func setup() &#123; self.isUserInteractionEnabled = true let longPressGestureRecognizer = UILongPressGestureRecognizer(target: self, action: #selector(longPressAction(_:))) self.addGestureRecognizer(longPressGestureRecognizer)&#125; 在长按事件中实现复制功能使用 UIMenuController 弹出复制菜单.使用简介 123456789101112131415161718192021@objc private func longPressAction(_ sender: UIGestureRecognizer) &#123; guard sender.state == .began else &#123; return &#125; // 变为第一响应者 self.becomeFirstResponder() // 菜单控制器 let menuController = UIMenuController.shared // 复制 item let copyItem = UIMenuItem(title: "复制", action: #selector(copyText)) // 添加 item 到 menu 控制器 menuController.menuItems = [copyItem] // 设置菜单控制器点击区域为当前控件 bounds menuController.setTargetRect(self.bounds, in: self) // 菜单显示器可见 menuController.setMenuVisible(true, animated: true)&#125; 确认 label 具有的操作能力 123456override func canPerformAction(_ action: Selector, withSender sender: Any?) -&gt; Bool &#123; if action == #selector(copyText) &#123; return true &#125; return false&#125; 实现将 label 内容放到剪切板 123@objc private func copyText() &#123; UIPasteboard.general.string = self.text&#125; 在需要的地方使用 1let label = YTTCopyLabel(frame: CGRect(x: 20, y: 100, width: self.view.frame.width - 40, height: 30)) 运行效果如下:YTTCopyLabel.swift 通过设置 UITextView 的属性实现UITextView 本身就有复制的功能,他有两个属性，一个可控制其是否编辑，一个是可控制其是否可选,只需将其可编辑设为 false1isEditable = false 创建 YTTCustomTextView,使其继承与 UITextView 12class YTTCustomTextView: UITextView &#123;&#125; 重写父类方法,使其使其编辑功能 1234567891011121314151617@IBInspectablevar isAutoLayout: Bool = true // 是否是自适应布局override func awakeFromNib() &#123; super.awakeFromNib() setup()&#125;override init(frame: CGRect, textContainer: NSTextContainer?) &#123; super.init(frame: frame, textContainer: textContainer) setup()&#125;private func setup() &#123; self.isEditable = false self.isScrollEnabled = false // 设为 false 可自适应&#125; 重写属性 text 与 attributedText, 进行自适应布局 12345678910111213141516171819202122232425262728293031override var text: String! &#123; get &#123; return super.text &#125; set &#123; super.text = newValue if !isAutoLayout &#123; let width = self.bounds.width - (self.contentInset.left + self.contentInset.right + self.textContainerInset.left + self.textContainerInset.right + self.textContainer.lineFragmentPadding * 2) let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.lineBreakMode = self.textContainer.lineBreakMode let wordHeight = (self.text as NSString).boundingRect(with: CGSize(width: width, height: CGFloat.greatestFiniteMagnitude), options: [.usesLineFragmentOrigin, .usesFontLeading], attributes: [.font : self.font!, .paragraphStyle: paragraphStyle ], context: nil).height + self.textContainerInset.top + self.textContainerInset.bottom + self.textContainer.lineFragmentPadding * 2 + self.contentInset.top + self.contentInset.bottom let rect = CGRect(x: self.frame.minX, y: self.frame.minY, width: width, height: wordHeight) self.frame = rect &#125; &#125;&#125;override var attributedText: NSAttributedString! &#123; get &#123; return super.attributedText &#125; set &#123; super.attributedText = newValue if !isAutoLayout &#123; let width = self.bounds.width - (self.contentInset.left + self.contentInset.right + self.textContainerInset.left + self.textContainerInset.right + self.textContainer.lineFragmentPadding * 2) let wordHeight = newValue.boundingRect(with: CGSize(width: width, height: CGFloat.greatestFiniteMagnitude), options: [.usesLineFragmentOrigin, .usesFontLeading], context: nil).height + self.textContainerInset.top + self.textContainerInset.bottom + self.textContainer.lineFragmentPadding * 2 + self.contentInset.top + self.contentInset.bottom let rect = CGRect(x: self.frame.minX, y: self.frame.minY, width: width, height: wordHeight) self.frame = rect &#125; &#125;&#125; 判断屏幕点击事件是否在本视图,不是取消选中状态 12345678// 设置点击空白取消选中效果override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123; // 判断点击点是否在本视图 if !self.point(inside: point, with: event) &#123; self.selectedRange = NSMakeRange(0, 0) // 设置为 NSMakeRange(0, 0) 取消选中效果 &#125; return super.hitTest(point, with: event)&#125; YTTCustomTextView]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>自定义视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTTCache]]></title>
    <url>%2F2018%2F08%2F27%2FYTTCache%2F</url>
    <content type="text"><![CDATA[iOS 开发中经常会用到本地存储,加之最近在了解组件化,所以对本地存储这块做了组件化处理,且在完善中… YTTCache使用 SQLite3 对数据进行存储,采用键值对形式存储数据.使用 SQLite.swift 进行数据库操作. InstallationYTTCache 可以通过 CocoaPods 安装. 只需要在你的 Podfile 添加:1pod 'YTTCache' Usage采用 SQLite3 进行存储,表格有5个字段: id, cache_data, cache_key, cache_time, cache_data_MD5. id: 数据唯一标识. cache_data: 需要缓存数据,采用 Data 数据类型,对应数据库 Blob 类型. cache_key: 数据对应的 key, 对字符串 MD5 的值. cache_time: 添加/修改数据的时间(时间戳). cache_data_MD5: 缓存数据的 MD5 值,查询时校验使用. YTTDataBase 基础类,通过 SQLite.swift 对数据库进行操作,实现了添加,修改,查询,删除操作. YTTCache 缓存操作的主要操作类,实现了添加,修改,查询,删除操作(主要针对 String 与 Data). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class YTTCache/// 缓存数据////// - Parameters:/// - value: 字符串/// - key: 键值/// - Returns: 是否缓存成功public class func storeString(_ value: String, key: String) -&gt; Bool /// 缓存数据////// - Parameters:/// - value: Data/// - key: 键值/// - Returns: 是否缓存成功public class func storeData(_ value: Data, key: String) -&gt; Bool /// 更新缓存数据////// - Parameters:/// - value: 字符串/// - key: 键值/// - Returns: 是否更新成功public class func updateStoreString(_ value: String, key: String) -&gt; Bool /// 更新缓存数据////// - Parameters:/// - value: data/// - key: 键值/// - Returns: 是否更新成功public class func updateStoreData(_ value: Data, key: String) -&gt; Bool /// 获取缓存信息////// - Parameter key: 键值/// - Returns: 获取到的 Datapublic class func dataForKey(_ key: String, timeoutIntervalForCache interval: TimeInterval = .greatestFiniteMagnitude) -&gt; Data? /// 获取缓存信息////// - Parameter key: 键值/// - Returns: 获取到的字符串public class func stringForKey(_ key: String, timeoutIntervalForCache interval: TimeInterval = .greatestFiniteMagnitude) -&gt; String? /// 清除某条数据////// - Parameter key: 键值/// - Returns: 是否清除成功public class func removeCacheByKey(_ key: String) -&gt; Bool /// 清除缓存////// - Returns: 是否清除成功public class func cleanCache() -&gt; Bool YTTRequestCache 基于 YTTCache 实现,缓存数据为 JSON 字符串, key 值通过 url 与参数生成. 1234567891011121314151617181920212223242526272829public class YTTRequestCache/// 缓存请求结果 JSON 数据////// - Parameters:/// - jsonStr: JSON 字符串/// - url: 请求 URL 地址/// - param: 请求参数/// - Returns: 是否缓存成功public class func storeJSONString(_ jsonStr: String, url: String, param: [String: Any]) -&gt; Bool /// 获取缓存 JSON 数据////// - Parameters:/// - url: 请求 URL 地址/// - param: 请求参数/// - timeoutIntervalForCache: 缓存时间(以秒为单位),默认永久/// - Returns: 缓存 JSON 字符串,没有返回 nilpublic class func JSONStringForKey(url: String, param: [String: Any], timeoutIntervalForCache interval: TimeInterval = .greatestFiniteMagnitude) -&gt; String? /// 删除某条 JSON 数据////// - Parameters:/// - url: 请求 URL 地址/// - param: 请求参数/// - Returns: 是否删除成功public class func removeJSONStringForKey(url: String, param: [String: Any]) -&gt; Bool Extension 对常用一些类进行扩展,方便数据缓存操作.(eg: 取: String.initWithCache(“students”) 保存: “students”.cache.storeWithKey(“students”)) StringExtensionUIImageExtensionDictionaryExtensionArrayExtension]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>三方库</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发常用三方库总结]]></title>
    <url>%2F2018%2F08%2F23%2FiOS%20%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS 开发中为了加快开发速度经常会引用一些三方库,对常用的库进行了总结. OC swift 介绍 网络请求 AFNetworking Alamofire 轻量级网络请求开源框架 图片加载 SDWebImage Kingfisher 在网络下载并缓存图片 轮播图 SDCycleScrollView ZCycleView ☆☆☆ “iOS图片、文字轮播器” ☆☆☆ 布局 Masonry SnapKit 自动布局框架 加载等待 MBProgressHUD/SVProgressHUD - 进度加载等待 加载 MJRefresh - 下拉刷新框架 模型转换 MJExtension/YYModel HandyJSON 模型序列化成JSON及反序列化库 SQLite FMDB SQLite.swift SQILite 管理工具 错误收集 Bugly - 用于项目上线后错误收集 银行卡扫描 FBYBankCardRecognition-iOS - 通过图像识别，可以快速、高效的识别银行卡信息。]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>三方库</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取系统信息]]></title>
    <url>%2F2018%2F08%2F21%2FiOS%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[iOS 开发经常需要获取手机系统一些消息,总结了常用的一些信息获取.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134class YTTSystemInfo &#123; /// 获取设备名称 class var deviceName: String &#123; return UIDevice.current.name &#125; /// 获取系统名称 class var systemName: String &#123; return UIDevice.current.systemName &#125; /// 系统版本号 class var systemVersion: String &#123; return UIDevice.current.systemVersion &#125; /// 获取设备唯一标示 class var deviceUUID: String? &#123; return UIDevice.current.identifierForVendor?.uuidString &#125; /// 获取设备型号 class var deviceModel: String &#123; return UIDevice.current.model &#125; /// 获取 app 名称 class var appName: String? &#123; return Bundle.main.infoDictionary?["CFBundleDisplayName"] as? String &#125; /// 获取 app 版本号 class var appVersion: String? &#123; return Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String &#125; /// 获取 app 构建版本号 class var appBuildVersion: String? &#123; return Bundle.main.infoDictionary?["CFBundleVersion"] as? String &#125; /// 获取设备具体型号 class var deviceModelName: String &#123; var systemInfo = utsname() uname(&amp;systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") &#123; identifier, element in guard let value = element.value as? Int8, value != 0 else &#123; return identifier &#125; return identifier + String(UnicodeScalar(UInt8(value))) &#125; switch identifier &#123; case "i386": return "Simulator" case "x86_64": return "Simulator" // iphone 系列 case "iPhone1,1": return "iPhone 1G" case "iPhone1,2": return "iPhone 3G" case "iPhone2,1": return "iPhone 3GS" case "iPhone3,1": return "iPhone 4 (GSM)" case "iPhone3,2": return "Verizon iPhone 4" case "iPhone3,3": return "iPhone 4 (CDMA/Verizon/Sprint)" case "iPhone4,1": return "iPhone 4S" case "iPhone5,1": return "iPhone 5" case "iPhone5,2": return "iPhone 5" case "iPhone5,3": return "iPhone 5C" case "iPhone5,4": return "iPhone 5C" case "iPhone6,1": return "iPhone 5S" case "iPhone6,2": return "iPhone 5S" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone7,2": return "iPhone 6" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPhone8,4": return "iPhone SE" case "iPhone9,1": return "iPhone 7 (CDMA)" case "iPhone9,2": return "iPhone 7 Plus (CDMA)" case "iPhone9,3": return "iPhone 7 (GSM)" case "iPhone9,4": return "iPhone 7 Plus (GSM)" case "iPhone10,1": return "iPhone 8 (CDMA)" case "iPhone10,2": return "iPhone 8 Plus (CDMA)" case "iPhone10,3": return "iPhone X (CDMA)" case "iPhone10,4": return "iPhone 8 (GSM)" case "iPhone10,5": return "iPhone 8 Plus (GSM)" case "iPhone10,6": return "iPhone X (GSM)" // iPod 系列 case "iPod1,1": return "iPod Touch 1G" case "iPod2,1": return "iPod Touch 2G" case "iPod3,1": return "iPod Touch 3G" case "iPod4,1": return "iPod Touch 4G" case "iPod5,1": return "iPod Touch 5G" case "iPod7,1": return "iPod Touch 6G" // iPad case "iPad1,1": return "iPad" case "iPad1,2": return "iPad 3G" case "iPad2,1": return "iPad 2 (WiFi)" case "iPad2,2": return "iPad 2 (GSM)" case "iPad2,3": return "iPad 2 (CDMA)" case "iPad2,4": return "iPad 2 (32nm)" case "iPad2,5": return "iPad Mini (WiFi)" case "iPad2,6": return "iPad Mini (GSM)" case "iPad2,7": return "iPad Mini (CDMA)" case "iPad3,1": return "iPad 3(WiFi)" case "iPad3,2": return "iPad 3(CDMA)" case "iPad3,3": return "iPad 3(4G)" case "iPad3,4": return "iPad 4 (WiFi)" case "iPad3,5": return "iPad 4 (4G)" case "iPad3,6": return "iPad 4 (CDMA)" case "iPad4,1": return "iPad Air" case "iPad4,2": return "iPad Air" case "iPad4,3": return "iPad Air" case "iPad4,4": return "iPad Mini 2" case "iPad4,5": return "iPad Mini 2" case "iPad4,6": return "iPad Mini 2" case "iPad4,7": return "iPad Mini 3" case "iPad4,8": return "iPad Mini 3" case "iPad4,9": return "iPad Mini 3" case "iPad5,1": return "iPad Mini 4" case "iPad5,2": return "iPad Mini 4" case "iPad5,3": return "iPad Air 2" case "iPad5,4": return "iPad Air 2" case "iPad6,3": return "iPad PRO (12.9)" case "iPad6,4": return "iPad PRO (12.9)" case "iPad6,7": return "iPad PRO (9.7)" case "iPad6,8": return "iPad PRO (9.7)" case "iPad6,11": return "iPad 5" case "iPad6,12": return "iPad 5" case "iPad7,1": return "iPad PRO 2 (12.9)" case "iPad7,2": return "iPad PRO 2 (12.9)" case "iPad7,3": return "iPad PRO (10.5)" case "iPad7,4": return "iPad PRO (10.5)" default: return "" &#125; &#125;&#125; 附件下载]]></content>
      <categories>
        <category>iOS</category>
        <category>系统信息</category>
      </categories>
      <tags>
        <tag>系统信息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Navigation 返回按钮]]></title>
    <url>%2F2018%2F08%2F21%2Fswift%20%E8%87%AA%E5%AE%9A%E4%B9%89Navigation%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[UINavigationController 是 iOS 开发中常用的空间,在开发中难免会遇到一些样式与我们需求不相符合,这里针对于返回按钮(backBarButtonItem)进行总结. 通过继承与 NavigationController 的子类实现自定义返回按钮 新建类继承与 UINavigationController 通过重写 pushViewController,方法设置返回按钮1234567override func pushViewController(_ viewController: UIViewController, animated: Bool) &#123; if self.viewControllers.count &gt; 0 &#123; viewController.hidesBottomBarWhenPushed = true viewController.navigationItem.leftBarButtonItem = UIBarButtonItem(image: UIImage(named: "icon_nav_back")?.withRenderingMode(.alwaysOriginal), style: .plain, target: self, action: #selector(back)) &#125; super.pushViewController(viewController, animated: true)&#125; 设置滑动返回如果使用系统的返回按钮是有轻扫左边缘返回的操作的,如果设置了 leftBarButtonItem 滑动返回将消失. 设置 interactivePopGestureRecognizer 的代理为当前类 实现 gestureRecognizerShouldBegin 代理方法123func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return self.viewControllers.count &gt; 1&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>导航栏</category>
      </categories>
      <tags>
        <tag>navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UILabel 加载 HTML]]></title>
    <url>%2F2018%2F08%2F13%2FUILabel%E5%8A%A0%E8%BD%BDHTML%2F</url>
    <content type="text"><![CDATA[iOS 开发中为了开发方便时长会加载一些 HTML 静态页面,目前主要使用 UIWebView 与 WKWebView 进行加载,但仅仅作为页面展示我认为没有必要使用他们,且他们高度自适应比较繁琐,因此比较推荐使用 UILabel 加载富文本形式展现 HTML 页面. OC 代码12NSAttributedString * attrStr = [[NSAttributedString alloc] initWithData:[htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123; NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType &#125; documentAttributes:nil error:nil];label.attributedText = attrStr; swift 代码123if let data = htmlStr.data(using: String.Encoding.unicode), let attributedStr = try? NSAttributedString(data: data, options: [NSAttributedString.DocumentReadingOptionKey.documentType : NSAttributedString.DocumentType.html], documentAttributes: nil) &#123; label.attributedText = attributedStr&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>富文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIButton 设置图片与文字位置]]></title>
    <url>%2F2018%2F08%2F10%2FUIButton%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E4%B8%8E%E6%96%87%E5%AD%97%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[UIButton 可谓是 iOS 开发中使用频率最多的控件了,然而很多时候系统为我们提供的 UIButton 样式不能满足我们的需求,需要我们对样式进行调整,主要对文字图片的位置进行总结. 以 UIButton 为跟视图,添加 UIImageView 与 UILabel 优点: 处理简单,可以很便捷的进行布局. 缺点: UIButton 本身自带有 UIImageView 与 UILabel 控件,重复. 通过设置 titleEdgeInsets 与 imageEdgeInsets 属性 优点: 可以直接调整 UIButton 的 UIImageView 与 UILabel,不必再次添加. 确定: 便宜量计算比较复杂. 注意: 设置 titleEdgeInsets 与 imageEdgeInsets 属性并不会调整 UIButton, UIImageView, UILabel 的 frame, 如果偏移后超出父视图范围则不会响应. 自定义 UIButton新建 YTTCustomButton 类,继承与 UIButton, 通过重写 layoutSubviews 方法进行调整. imageAlignment属性: YTTButtonImageAlignment 类型 ( top, bottom, right, left 图片位置) spaceBetweenTitleAndImage: CGFloat 类型, 图片文字间距 CustomButton 下载]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>自定义视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 忽略不必要提交的文件]]></title>
    <url>%2F2018%2F08%2F09%2Fgit%E5%BF%BD%E7%95%A5%E4%B8%8D%E5%BF%85%E8%A6%81%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在开发中版本控制是开发人员必不可少的,现在常用的版本控制主要是 git/svn.在实际开发过程中会产生一些中间文件或者项目中有些文件是不需要进行版本管理的,我们可以通过设置 .gitignore 文件忽略这些文件. 创建 .gitignore 文件 指定不需要提交的文件需要在版本管理根目录下创建 .gitignore (gitignore是隐藏文件，所以前面有个点), 与 .git 同级 进入版本管理文件夹: cd /Users/**/**/** 创建 .gitignore 文件: touch .gitignore 编辑 .gitignore 文件: vim .gitignore 编辑 .gitignore 文件忽略规则： ’#’是注释，将被git忽略。 可以使用Linux通配符。 如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略 如果名称的最前面有一个路径分隔符（/）,表示将忽略的文件在此目录下，而子目录中的文件不忽略 如果名称的最后面有一个路径分隔符（/）,表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略） gitignore 配置例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint## Obj-C/Swift specific*.hmap*.ipa*.dSYM.zip*.dSYM# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-controlPods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build# fastlane## It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the# screenshots whenever they are needed.# For more information about the recommended setup visit:# https://docs.fastlane.tools/best-practices/source-control/#source-controlfastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_output# Code Injection## After new code Injection tools there&apos;s a generated folder /iOSInjectionProject# https://github.com/johnno1962/injectionforxcodeiOSInjectionProject/# fastlanefastlane]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 总结]]></title>
    <url>%2F2018%2F06%2F21%2FiOS%20%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS是由苹果公司开发的移动操作系统. iOS 简介开发语言Object-C 通常写作ObjC或OC和较少用的Objective C或Obj-C，是扩充C的面向对象编程语言。OC 完全兼容 C语言. 面向对象语言(C 语言面向过程). 是MAC OSX和IOS开发的基础语言。 Swift 苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序. Swift和Objective-C共用一套运行时环境,项目中可以通过桥接的方式互相调用. 开发工具 Xcode: 运行在操作系统Mac OS X上的集成开发工具（IDE），由苹果公司开发。 iOS 基础APP 生命周期iOS 应用有5中状态: Not running 应用还没启动或正在运行但是中途被系统停止 Inactive 应用正在前台运行(不接收事件) Active 应用正在前台运行(接收事件) Background 应用处于后台运行(还在执行代码) Suspended 应用处于后台运行(停止执行代码)对应的函数:12345678910111213141516//应用将要进入非活动调用 (不接受消息或事件)- (void)applicationWillResignActive:(UIApplication *)application;//应用进入活动调用 (接收消息或事件)- (void)applicationDidBecomeActive:(UIApplication *)application;//应用进入后台调用 (设置后台继续运行)- (void)applicationDidEnterBackground:(UIApplication *)application;//应用将要进入前台调用- (void)applicationWillEnterForeground:(UIApplication *)application;//应用将要退出调用 (保存数据,退出前清理)- (void)applicationWillTerminate:(UIApplication *)application;//应用被终止前调用 (内存清理,方式应用被终止)- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application;//应用载入后调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;//应用打开URL时调用- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url; 内存管理机制(引用计数)简介OC 引入引用计数机制来跟踪并管理对象的生命周期.iOS 5之前采用 MRC(手动内存管理) 管理内存.需用开发人员手动调用reatain,release等方法.iOS 5之后采用 ARC(自动内存管理) 管理内存,不用开发人员去关心引用计数的变化. 操作 对应 OC 方法 引用计数变化 创建对象 alloc,new 等 生成对象,引用计数设置为 1 持有对象 reatain 引用计数 +1 释放对象 release 引用计数 -1 废弃对象 dealloc 引用计数为0,释放内存 alloc 与 dealloc,reatain与 release 成对存在, 谁创建谁释放，谁retain谁释放只有当引用计数为 0 是对象才会销毁回收内存. 工作原理 当我们创建(alloc)一个新对象A的时候，它的引用计数从零变为 1. 当有一个指针指向这个对象A，也就是某对象想通过引用保留(retain)该对象A时，引用计数加 1. 当某个指针/对象不再指向这个对象A，也就是释放(release)该引用后，我们将其引用计数减 1. 当对象A的引用计数变为 0 时，说明这个对象不再被任何指针指向(引用)了，这个时候我们就可以将对象A销毁，所占内存将被回收，且所有指向该对象的引用也都变得无效了。系统也会将其占用的内存标记为“可重用”(reuse). 属性声明@property(nonatomic, strong)UITextField *textField;OC 采用 ‘@property’ 声明对象, 会默认生成一个 ‘_textField’ 成员变量与与之对应的 ‘setter/getter’ 方法. 属性修饰符 修饰符 描述 引用计数变化 copy 复制,创建一个新对象,通常修饰 NSString,NSArray,NSDictionary,NSSet 新对象引用计数为 1,旧对象不变 retain 释放旧对象,主要用于(MRC) 释放旧对象,计数 -1,新对象 retain, 计数 +1 strong 强引用,与 retain相似 释放旧对象,计数 -1,新对象 retain, 计数 +1 assign 修饰基本数据类型 不变 weak 与assign类似,修饰对象,对消销毁后自动变成 nil,主要用于修饰 delegate 不变 readwrite 可读写,生成 setter 与 getter 方法 - readonly 只读,只为属性生成 getter 方法 - nonatomic 非原子属性,不为 setter 方式加锁,非线程安全,通常采用这种,执行效率高 - atomic 原子属性,为 setter 方式加锁,线程安全 - 注意问题 对 block 修饰 Strong,copy 都可以,建议使用 copy. block 声明默认为栈变量,为了能够在block的声明域外使用，所以要把block拷贝（copy）到堆，所以说为了block属性声明和实际的操作一致，最好声明为copy。 NSString,NSArray,NSDictionary,NSSet 建议使用 copy. 当将 NSMutableString 赋值给 NSString 时, strong 修饰只会进行浅拷贝(引用计数 +1),NSMutableString与NSString 指向同一内存空间,NSMutableString修改时NSString会随之改变. copy 修饰深拷贝(复制内存单元),NSMutableString与NSString 指向不同内存空间,NSMutableString修改时NSString不会改变. __weak __Strong __block 在 block 使用时有时为了避免造成循环引用会用 __weak __Strong 进行修饰下. 有时在 block 中,为了避免对象过早释放用 __Strong 修饰. 数据持久化 读写文件: 比较复杂,对对象保存需要进行归档反归档处理. 云端存储: 需要后台配合. 本地数据库(SQLite,CoreDate): CoreDate 是 iOS5 之后出现的,实质是对 SQLite 的封装. NSUserDefaults: 系统自带的持久化类,进行简单数据存储(用户登录信息等). 类继承关系(单继承)iOS 所有的类都继承与 NSObject, 主要分为 UI 和 NS 两大类. UI 主要为视图, NS 为数据操作.图解: 其他:UIViewController 生命周期: 初始化 –&gt; loadView –&gt; viewDidLoad –&gt; viewWillAppear –&gt; viewWillLayoutSubviews –&gt; viewDidLayoutSubviews –&gt; viewDidAppear –&gt; viewWillDisappear –&gt; viewDidDisappear –&gt; dealloc 传值 属性传值 block 传值 代理传值 通知传值 单例传值 持久化传值 协议与代理在iOS开发中，Protocol是一种经常用到的设计模式，苹果的系统框架中也普遍用到了这种方式,比如UITableView中的.协议声明:12345678910111213#import &lt;Foundation/Foundation.h&gt;@protocol ProtocolDelegate &lt;NSObject&gt;// 必须实现方法@required- (NSString*)getName;// 可选方法@optional- (NSString*)getAge;@end 协议使用 协议是一系列标准的方法列表，可以被任何类实现. 协议中不能声明成员变量，只要一个类遵守了这个协议，也相当于拥有了该协议中所有方法的声明. 父类遵守了该协议，那么它的子类也就都遵守该协议,可以遵守多个协议. 代理: 当前类(委托者)将一些操作委托给另一个类(代理)去完成.委托者需要做的事： 创建协议（也就是代理要实现的方法） 声明委托变量 设置代理（也可以在代理中设置） 利用委托变量来调用协议方法（也就是让代理者开始执行协议）代理需要做的事： 遵循协议 实现协议方法 数据请求iOS 中级响应者链 响应对象: 继承自UIResponder的对象称之为响应者对象. 响应事件: 触摸事件、点按事件(长按,多次点击,轻点等)、加速事件和远程控制. 响应者链: 由多个响应者组合起来的链条 事件产生与传递 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中. UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow). 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步. 找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理. 如果调用了[super touches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者，调用上一个响应者的touches….方法注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 事件响应 如果视图不响应事件，则将其传递给它的父视图 在最顶级的视图层次结构中，如果都不能处理收到的事件或消息，则其将事件或消息传递给UIWindow对象进行处理 如果UIWindow对象也不处理，则其将事件或消息传递给UIApplication对象处理 如果UIApplication也不能处理该事件或消息，则将该事件丢弃如何判断上一个响应者 如果当前这个view不是控制器的view, 那么它的父控件就是上一个响应者 如果当前这个view是控制器的view, 那么控制器就是上一个响应者 UIView不能接收触摸事件的情况 不允许交互: userInteractionEnabled = NO(eg: UIImageView) 隐藏 透明度: 透明度&lt;0.01 子视图超出了父视图区域 当前 View 被遮挡 分类(category)与类扩展(extension)分类 在不改变原类的基础上为一个类扩展方法. 主要用法为系统类扩展方法 不可添加成员变量. 如果要添加成员变量需要自己实现 setter 和 getter 方法(runtime). 分类文件(.h,.m),以为 Person 添加分类为例,可以通过 Person 实例对象直接调用 playFootBall 方法(分类方法执行优先级高于本类). Person+sport.h1234567#import "Person.h"@interface Person (sport)- (void)playFootBall;@end Person+sport.m123456789#import "Person+sport.h"@implementation Person (sport)- (void)playFootBall &#123; NSLog(@"playFootBall");&#125;@end 类扩展类扩展是分类的一个特例,为一个类添加一些私有成员变量和方法(常用).类扩展定义的方法，须在类的implement 中实现类扩展可以定义属性声明:12345#import "Person.h"@interface Person ()- (void)say;@end 分类与继承iOS 中分类(Categories) 和 继承(Inherit)有相同的功能，但在一些细节上又有差异，如何选择。使用继承: 扩展方法与原方法名相同,还需要使用父类方法. 扩展类属性(分类不能扩展类属性)使用分类: 为系统类添加方法(eg: 为 NSString 添加字符串校验). 开发人员针对自己的类,将相关方法分组到不同的文件. UITableView 重用机制UITableView 是 iOS 开发中最长用的控件,为了节省内存开销, UITableView 使用重用机制(重用 cell 单元格). 使用重用机制创建 cell 定义重用标示(static 修饰字符串). 在重用池取出 cell. 若重用池没有可用 cell, 创建新的 cell.12345static NSString *reuseIndentifier = @"MyCell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:reuseIndentifier]; &#125; 原理UITableView 维护这两个队列,单前可视 cell 队列 visiableCells, 可重用 cell 队列 reusableTableCells(重回池).在最初visiableCells, reusableTableCells 都为空, “UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@”cell”];” 获取 cell 为 nil, 执行 cell 初始化方法创建显示并存入到 visiableCells.如果屏幕最多显示 cell 个数为10,当加载完第11个 cell 时创建的第一个 cell 在 visiableCells 移除加入到 reusableTableCells 中,所以在加载第12个 cell 时只需在 reusableTableCells 取出 cell 即可.第十二个 cell 加载完成后创建的第二个 cell 移出 visiableCells 进入 reusableTableCells 中,依次类推(理论讲只需创建11个 cell 就可). 遇到问题和优化 重取出来的cell是有可能已经捆绑过数据或者加过子视图的，造成视图叠加混乱的现象 删除已有数据或子视图. 放弃了重用机制，每次根据indexPath获取对应的cell返回(内存销耗特大). 结合 MJFresh 实现数据分页加载. 结合 SDWebImage 实现 cell 中图片异步加载以及缓存.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS音视频播放]]></title>
    <url>%2F2018%2F06%2F16%2FiOS%20%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[按公司需求需要对音频文件进行后台播放,借此机会对音频播放做了个总结.主要针对 AVPlayer 进行详细说明. iOS 各播放器比较 名称 使用环境 优点 确点 System Sound Services AVFoundation C语言的底层写法，节省内存 支持的格式有限，音量无法通过音量键控制，而且播放方式单一。 AVAudioPlayer AVFoundation 抒写效率更高，基本上支持所有的音频格式，对播放的控制，如循环播放，声音大小，暂停等比较方便。 对内存的消耗会多些。不支持流式，即无法播放在线音乐。 AVPlayer AVFoundation 可以播放音视频,可播放在线音乐,使用灵活 MPMoviePlayerController MediaPlayer 简单易用 不可定制 AVPlayerViewController AVKit 简单易用 不可定制 IJKPlayer IJKMediaFramework 定制度高，支持流媒体播放 使用稍复杂 AVPlayer 使用简介AVPlayer 是iOS上常用的视频播放器组件，支持常见的音视频格式,支持流播放,可以播放在线音乐.支持视频格式： WMV，AVI，MKV，RMVB，RM，XVID，MP4，3GP，MPG等。支持音频格式：MP3，WMA，RM，ACC，OGG，APE，FLAC，FLV等。 相关类 AVPlayer：播放器,控制播放器的播放，暂停，播放速度. AVURLAsset : AVAsset 的一个子类，使用 URL 进行实例化，实例化对象包换 URL 对应视频资源的所有信息. AVPlayerItem：管理资源对象，提供播放数据源. AVPlayerLayer：负责显示视频，如果没有添加该类，只有声音没有画面. 简单使用使用 url 创建 AVPlayer1let player = AVPlayer(url: URL(string: "http://www.xxxx.mp3")) 使用 AVPlayerItem 创建 AVPlayer12345678910if let url = URL(string: "http://www.***.mp3") &#123; let asset = AVAsset(url: url) guard asset.isPlayable else&#123; // 检测文件是否可播放 return &#125; let playItem = AVPlayerItem(asset: asset) let player = AVPlayer(playerItem: playItem) player.play()&#125; AVPlayer 控制播放123player.play() // 播放player.pause() //暂停player.rate = 1.0 // 播放速度 通过通知监听播放状态变化123456789//播放完成AVPlayerItemDidPlayToEndTimeNotification//播放失败AVPlayerItemFailedToPlayToEndTimeNotification//异常中断AVPlayerItemPlaybackStalledNotification// eg: 播放结束通知NotificationCenter.default.addObserver(self, selector: #selector(finish(_:)), name: NSNotification.Name.AVPlayerItemDidPlayToEndTime, object: nil) 监听播放进度12345678// 添加周期时间观察者 一秒执行一次 blocklet timeObserver = player.addPeriodicTimeObserver(forInterval: CMTime(seconds: 1, preferredTimescale: 1), queue: DispatchQueue.main, using: &#123; [weak self] (cmTime) in if let totalTime = self?.currentPlayItem?.duration &#123; self?.delegate?.player(self!, currentTime: cmTime.seconds, totalTime: totalTime.seconds) &#125;&#125;)// 不要忘记移除player.removeTimeObserver(observer) AVPlayerItem 创建1234567891011121314// 使用 AVAsset 创建if let url = URL(string: "http://www.***.mp3") &#123; let asset = AVAsset(url: url) guard asset.isPlayable else&#123; // 检测文件是否可播放 return &#125; let playItem = AVPlayerItem(asset: asset)&#125;// 使用 URL 创建if let url = URL(string: "http://www.***.mp3") &#123; let playItem = AVPlayerItem(url: url)&#125; 监听 AVPlayerItem 状态和缓存进度12345678// 监听 playerItem 状态变化playItem.addObserver(self, forKeyPath: "status", options: .new, context: nil)// 监听缓存时间playItem.addObserver(self, forKeyPath: "loadedTimeRanges", options: .new, context: nil)// 移除监听currentPlayItem?.removeObserver(self, forKeyPath: "status")currentPlayItem?.removeObserver(self, forKeyPath: "loadedTimeRanges") 123456789101112131415161718192021222324override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if object is AVPlayerItem &#123; if keyPath == "status" &#123; if let playerItem = object as? AVPlayerItem &#123; switch playerItem.status &#123; case .readyToPlay: // 准备播放 case .failed: // 加载失败 default: // 未知状态 &#125; &#125; &#125; if keyPath == "loadedTimeRanges" &#123; if let playerItem = object as? AVPlayerItem &#123; if let timeRange = playerItem.loadedTimeRanges.first as? CMTimeRange &#123; let cache = timeRange.start.seconds + timeRange.duration.seconds // 缓存总时长 &#125; &#125; &#125; &#125; 音频后台播放开启所需后台模式选中Targets–&gt;Capabilities–&gt;BackgroundModes–&gt;ON,并勾选Audio and AirPlay选项，如下图:或者 plist 文件添加如下字段:利用 AVAudioSession 申请后台播放权限 1234567let session = AVAudioSession.sharedInstance()do &#123; try session.setActive(true) try session.setCategory(AVAudioSessionCategoryPlayback)&#125; catch &#123; print(error)&#125; 在播放控制界面接受远程控制(Remote Control)开启远程控制12// 声明接收Remote Control事件UIApplication.shared.beginReceivingRemoteControlEvents() 设置 Remote Control 响应12345// 响应 Remote Control事件MPRemoteCommandCenter.shared().playCommand.addTarget(self, action: #selector(play))MPRemoteCommandCenter.shared().nextTrackCommand.addTarget(self, action: #selector(next))MPRemoteCommandCenter.shared().pauseCommand.addTarget(self, action: #selector(pause))MPRemoteCommandCenter.shared().previousTrackCommand.addTarget(self, action: #selector(previous)) 移除 Remote Control 响应1234567// 在关闭播放页面时记得移除MPRemoteCommandCenter.shared().playCommand.removeTarget(self, action: #selector(play))MPRemoteCommandCenter.shared().nextTrackCommand.removeTarget(self, action: #selector(next))MPRemoteCommandCenter.shared().pauseCommand.removeTarget(self, action: #selector(pause))MPRemoteCommandCenter.shared().previousTrackCommand.removeTarget(self, action: #selector(previous))// 停止响应 Remote ControlUIApplication.shared.endReceivingRemoteControlEvents() 通过重写父类方法响应外部事件 开启接受远程控制 使当前页面成为第一响应者 重写 remoteControlReceivedWithEvent 方法. UIEvent Type 取值: UIEventSubtypeRemoteControlTogglePlayPause // 暂停 UIEventSubtypeRemoteControlPreviousTrack // 上一首 UIEventSubtypeRemoteControlNextTrack // 下一首 UIEventSubtypeRemoteControlPlay // 播放 UIEventSubtypeRemoteControlPause // 暂停 关闭接受远程控制 锁屏页面显示播放信息(Now Playing Center)使用 MPNowPlayingInfoCenter 设置锁屏页面音乐信息. 1234567891011121314func setLockScreenPlayingInfo(_ info: YTTMediaInfo) &#123; // Now Playing Center可以在锁屏界面展示音乐的信息，也达到增强用户体验的作用。 // https://www.jianshu.com/p/458b67f84f27 var infoDic: [String : Any] = [:] infoDic[MPMediaItemPropertyTitle] = info.title // 歌曲名 infoDic[MPMediaItemPropertyArtist] = info.singer // 歌手 if let img = info.image &#123; infoDic[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(image: img) // 专辑图片 &#125; infoDic[MPMediaItemPropertyPlaybackDuration] = info.totalTime // 歌曲总时长 infoDic[MPNowPlayingInfoPropertyElapsedPlaybackTime] = info.currentTime // 当前播放时间 infoDic[MPNowPlayingInfoPropertyPlaybackRate] = 1.0 // 播放速度 MPNowPlayingInfoCenter.default().nowPlayingInfo = infoDic&#125; 注意: MPNowPlayingInfoPropertyElapsedPlaybackTime 设置的并不是时时的,他是根据你设置的值进行计时的,如果想要在锁屏页面得到准确的时间,请及时刷新 MPNowPlayingInfoPropertyElapsedPlaybackTime 的值.当暂停时要暂停播放时间,只需将 MPNowPlayingInfoPropertyPlaybackRate 设置为 0.播放时设置回 1. 补充说明iOS 对后台管理十分严格,任何 app 都有大约3分钟或者10分钟的后台执行时间.3分钟或者10分钟后, app 就会被强制挂起.使用 AVAudioSession 申请后台权限时,可以保证播放本地音乐能在后台长久播放,当播放网络音乐时就会出现不能播放情况,针对这情况使用了 beginBackgroundTask 设置后台任务 ID,通过这种方式我们大约可以获得额外的 10 分钟来执行后台任务.为了能无限后台播放网络音乐添加计时器,当即将挂起时再次申请后台任务 ID. 1234567891011121314151617181920func applicationDidEnterBackground(_ application: UIApplication) &#123; // 这样做，可以在按home键进入后台后 ，播放一段时间，几分钟吧。但是不能持续播放网络歌曲，若需要持续播放网络歌曲，还需要申请后台任务id bgTask = application.beginBackgroundTask(expirationHandler: nil) timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(timerAction), userInfo: nil, repeats: true)&#125;@objc func timerAction() &#123; timerCount = timerCount + 1 if timerCount &lt; 500 &#123; return &#125; timerCount = 0 let newTask = UIApplication.shared.beginBackgroundTask(expirationHandler: nil) if bgTask != UIBackgroundTaskInvalid &amp;&amp; newTask != UIBackgroundTaskInvalid &#123; UIApplication.shared.endBackgroundTask(bgTask) bgTask = newTask &#125; &#125; 遇到的坑关于 rate 倍数播放对于 AVPlayer 的暂停和播放是通过 rate 的值来判断的,但 rate 为 1 时.播放状态,但其为 0 时为暂停.每次调用 play() 方法时,rate 的值都将会置为 1,所以当调用 play 方法时,需要重新设置 rate 的值. 关于AVPlayerItem 切换在 iOS9 以上系统测试时AVPlayerItem切换正常,但当在 iOS8 系统下,切换了AVPlayerItem 发现无法进行播放,针对这进行百度得到解决方式,iOS8 对于replaceCurrentItem方法支持不是很好,需要每次重新创建 AVPlayer. 其他 AVPlayer那些坑 项目参考地址]]></content>
      <categories>
        <category>iOS</category>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发之 CoreData]]></title>
    <url>%2F2018%2F06%2F01%2FiOS%20%E5%BC%80%E5%8F%91%E4%B9%8B%20CoreData%2F</url>
    <content type="text"><![CDATA[简介CoreData 是苹果公司封装的进行数据持久化的框架,首次在 iOS3.0版本的系统中出现,它允许按照实体-属性-值模型组织数据,并以 XML, 二进制文件或者 SQLite 数据文件格式持久化数据. 优点 CoreData 是苹果公司原生态的产品是在 iOS3.0版本系统出现,是苹果大力推广的技术之一,可以实现对 XML, 二进制文件和 SQLite 数据文件的访问. 可以节省代码量,一般要节省30%到70%的代码量. 支持可视化建模. CoreData 支持模型版本升级等. 创建工程 创建 CoreData 项目,记住选中 “Use Core Data”.项目会自动创建出数据模型文件. 创建出项目会发现多了 CoreDataDemo.xcdatamodeld 模型文件(可视化建模文件) 主要类 NSManagedObjectContext: 被管理对象上下文(数据管理器). NSManagedObjectModel: 被管理对象(数据模型器). NSPersistentStoreCoordinator: 持久化存储助理(数据链接器). 创建模型 点击 “CoreDataDemo.xcdatamodeld” 文件,添加实体. 这里我们需要创建Person和Card的实体以及实体属性: 选中Person实体，在Person中添加card属性: 选中Card实体，在Card中添加person属性: 添加后模型对应关系: 数据操作 获取上下文对象,在创建项目时, AppDelegate 提供了相应方法获取上下文. 1234var context: NSManagedObjectContext = &#123; let appDelegate = UIApplication.shared.delegate as! AppDelegate return appDelegate.persistentContainer.viewContext&#125;() 查询 123456789101112131415161718@IBAction func selected(_ sender: UIButton) &#123; let request = NSFetchRequest&lt;NSFetchRequestResult&gt;() request.entity = NSEntityDescription.entity(forEntityName: "Person", in: context) request.predicate = NSPredicate(format: "age=%@", "26") request.sortDescriptors = [NSSortDescriptor(key: "age", ascending: true)] do &#123; let result = try context.fetch(request) if let person = result as? [Person] &#123; for per in person &#123; print("\(per.name) : \(per.age) ---- \(per.card?.no) : \(per.card?.name)") &#125; &#125; &#125; catch &#123; print(error) &#125;&#125; 添加 1234567891011121314151617// 添加@IBAction func insert(_ sender: UIButton) &#123; let person = NSEntityDescription.insertNewObject(forEntityName: "Person", into: context) person.setValue(nameText.text, forKey: "name") person.setValue(Int(ageText.text!), forKey: "age") let card = NSEntityDescription.insertNewObject(forEntityName: "Card", into: context) card.setValue("123456", forKey: "no") card.setValue("学生卡", forKey: "name") person.setValue(card, forKey: "card") do &#123; try context.save() &#125;catch &#123; print(error) &#125;&#125; 修改 12345678910111213141516171819/// 修改数据////// - 修改数据要查询出需要修改的数据,依次修改@IBAction func update(_ sender: UIButton) &#123; let request = NSFetchRequest&lt;NSFetchRequestResult&gt;() request.entity = NSEntityDescription.entity(forEntityName: "Person", in: context) request.predicate = NSPredicate(format: "age=%@", "26") do &#123; let result = try context.fetch(request) if let person = result as? [Person] &#123; for per in person &#123; per.name = "Angelo" try context.save() &#125; &#125; &#125; catch &#123; print(error) &#125;&#125; 删除 12345678910111213141516171819/// 删除数据////// - 删除数据需要先查询出要删除的数据,依次删除@IBAction func deleter(_ sender: UIButton) &#123; let request = NSFetchRequest&lt;NSFetchRequestResult&gt;() request.entity = NSEntityDescription.entity(forEntityName: "Person", in: context) request.predicate = NSPredicate(format: "age=%@", "26") do &#123; let result = try context.fetch(request) if let person = result as? [Person] &#123; for per in person &#123; context.delete(per) &#125; &#125; &#125; catch &#123; print(error) &#125;&#125; GitHub 地址:https://github.com/AndyCuiYTT/CoreDataDemo]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>CoreData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 沙盒机制]]></title>
    <url>%2F2018%2F05%2F31%2FiOS%20%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[iOS 每个 APP 都有自己的存储空间,这个存储空间叫做沙盒. APP可以在自己的沙盒中进行数据存取操作,但不能访问其他 app 的沙盒空间.对 app 做一些数据存储或者文件缓存时,一般都保存在沙盒中. 沙盒机制简介目录结构沙盒机制根据访问权限和功能区别分为不同的目录: document,library,temp,.app, library又包含 caches 和preferences. document: 保存应用运行时生成的需要持久化的数据iTunes会自动备份该目录。苹果建议将在应用程序中浏览到的文件数据保存在该目录下. library: 这个目录下有两个目录 caches: 一般存储的是缓存文件，例如图片视频等，此目录下的文件不会再应用程序退出时删除，在手机备份的时候，iTunes不会备份该目录。 preferences: 保存应用程序的所有偏好设置iOS的Settings(设置)，我们不应该直接在这里创建文件，而是需要通过NSUserDefault这个类来访问应用程序的偏好设置。iTunes会自动备份该文件目录下的内容. temp: 临时文件目录，在程序重新运行的时候，和开机的时候，会清空tmp文件夹。 .app: 这个就是可运行的应用文件，带有签名的文件包，包含应用程序代码和静态数据. 特点 每个应用程序都在自己的沙盒内. 不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容. 应用程序向外请求或接收数据都需要经过权限认证. 沙盒操作获取沙盒路径获取沙盒根路径1let homePath = NSHomeDirectory() 获取 document 路径1let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) 获取 library 路径1let libraryPath = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true) 获取 cache 路径1let cachePath = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) 获取 preferences 路径由系统维护,不需要我们手动获取文件目录.可借助 UserDefault 维护 获取 tmp 路径1let tmpPath = NSTemporaryDirectory() 获取程序目录和内容 获取程序包路径let path = Bundle.main.resourcePath 获取图片资源路径let imagePath = Bundle.main.path(forResource: &quot;temp&quot;, ofType: &quot;png&quot;) 文件管理iOS 对文件进行管理需要用到文件管理器: FileManager. 检测文件是否存在FileManager.default.fileExists(atPath: filePath) 创建文件路径FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil) 创建文件FileManager.default.createFile(atPath: path, contents: data, attributes: nil) 文件删除FileManager.default.removeItem(atPath: path) 文件移动FileManager.default.moveItem(atPath: oldPath, toPath: newPath) 文件复制FileManager.default.copyItem(atPath: oldPath, toPath: newPath) 获取文件属性FileManager.default.attributesOfItem(atPath: filePath)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现 cell 加载网络图片自适应方案]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%AE%9E%E7%8E%B0cell%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[UITableView 是 iOS 开发中最常用的控件之一,使用 UITaleView 时最头疼的莫过于 cell 高度的计算,虽说在 iOS8.0 以后引入了自适应方法,但在适配过程中任然会遇到各种难题,尤其是为了满足产品需求进行复杂 cell 自定义时,高度计算可谓是难上加难.这里主要对开发中遇到的自定义 cell 是加载网络图片适配问题进行总结. 在开发中为了用户能有更好体验,对网络请求多采用异步请求的方式,更有甚者对请求数据做了本地缓存.图片作为 app 中最常见的展现形式无疑是最耗流量的,对图片的处理直接影响到用户的体验,好在有大神为我们提供了好的框架(Kingfisher,SDWebImage),大大提高了我们的开发效率. 图片的异步加载提高了用户体验,却在开发中遇到了新的难题,因为图片异步加载你无法提前预知图片的尺寸,在布局时难以控制 UIImageView 的大小,如果将 UIImageView 固定大小势必会造成图片的压缩或拉伸,现在主要针对于自定义 cell 时对图片自适应布局提一些建议. 固定 UIImageView 大小在开发中我们时常会将 UIImageView 固定大小或者固定宽高比例,通过设置 ImageView 的 contentMode 属性设置图片的显示风格.该方法简单容易造成图片压缩拉伸或显示不全问题.contentMode 取值: 12345678910111213141516171819202122232425262728public enum UIViewContentMode : Int &#123; case scaleToFill //缩放内容到合适比例大小 case scaleAspectFit //缩放内容到合适的大小，边界多余部分透明 case scaleAspectFill //缩放内容填充到指定大小，边界多余的部分省略 case redraw //重绘视图边界 case center //视图保持等比缩放,居中 case top //视图顶部对齐 case bottom //视图底部对齐 case left //视图左侧对齐 case right //视图右侧对齐 case topLeft //视图左上角对齐 case topRight //视图右上角对齐 case bottomLeft //视图左下角对齐 case bottomRight //视图右下角对齐&#125; 通过获取服务器存储的图片尺寸布局在上传图片时可以将图片的大小一起上传服务器保存,在用户加载图片时将图片信息和图片 URL 地址一起返回,根据返回的图片信息计算 UIImageView 的 size 进行布局.该方法比较简单,但需要后台配合使用. 通过监听图片加载刷新 cell 实现(配合 cell 自适应)无论 SDWebiamge 还是 Kingfisher,作者都给我们提供了图片加载完回调方法,我们可以在图片加载完后重新计算 cell 高度.该方法大大加大了 cell 的刷新频率.具体步骤: 在自定义 cell 中定义闭包变量.var refreshCell: ((IndexPath) -&gt; Void)? 在图片加载完成的回调中调用闭包,为了减少 cell 的刷新,判断是拉取网络数据还是加载的缓存数据,如果是网络数据调整图片大小并将调整后图片覆盖网络加载图片,如果是缓存图片不处理. 1234567iconImageView.kf.setImage(with: URL(string: iconImageURL), placeholder: UIImage(named: "tmp")) &#123; [weak self](image, error, type, url) in if type == .none &#123; self?.iconImageView.image = self?.iconImageView.image?.ytt.resetImageSizeWithWidth(UIScreen.main.bounds.width) ImageCache.default.store((image?.ytt.resetImageSizeWithWidth(UIScreen.main.bounds.width))!, forKey: (url?.absoluteString)!) self?.refreshCell?(indexPath) &#125;&#125; 在 TableView 回调方法中实现闭包,仅当 cell 展现在屏幕时刷新 12345cell.refreshCell = &#123;(index) in if (tableView.indexPathsForVisibleRows?.contains(index))! &#123; tableView.reloadRows(at: [index], with: .automatic) &#125;&#125; 通过 ImageIO 框架获取图片信息在给 UIImageView 赋值时通过 ImageIO 获取 image 的尺寸,修改 UIImageView 的大小.该方法需要在网络请求数据,加大了数据请求量.实现代码:123456789let imageSource = CGImageSourceCreateWithURL(URL(string: iconImageURL)! as CFURL, nil)if let result = CGImageSourceCopyPropertiesAtIndex(imageSource!, 0, nil) as? Dictionary&lt;String, Any&gt; &#123; if let width = result["PixelWidth"] as? CGFloat, let height = result["PixelHeight"] as? CGFloat &#123; let h = (UIScreen.main.bounds.width - 20) / (width / height) iconImageView.snp.remakeConstraints &#123; (make) in make.height.equalTo(h) &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>cell 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carthage 安装以及初步实用]]></title>
    <url>%2F2018%2F05%2F22%2FCarthage%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本人从事 iOS 开发已有2年多,用 swift 开发也有一年多的时间了,此前一直利用 cocopods 管理三方框架和依赖,最近了解到 Carthage 这个工具,本着学习的态度对这工具进行了了解. 官方地址: https://github.com/Carthage/Carthage Carthage 简介 Carthage 类似于 CocoaPods，为用户管理第三方框架和依赖，但不会自动修改项目文件和生成配置 Carthage 是去中心化的依赖管理工具，安装依赖时不需要去中心仓库获取 CocoaPods 所有依赖的索引，节省时间 对项目无侵入性，Carthage 设计上也比较简单，利用的都是 Xcode 自身的功能，开发者在创建依赖时，相比 CocoaPods 也简单许多 Carthage 管理的依赖只需编译一次，项目干净编译时，不会再去重新编译依赖，节省时间 自动将第三方框架编程为 Dynamic framework( 动态库 )与 CocoaPods 无缝集成，一个项目能同时拥有 CocoaPods 和 Carthage 缺点： 仅支持 iOS8 + 它只支持框架，所以不能用来针对 iOS 8 以前的系统版本进行开发支持的 Carthage 安装的第三方框架和依赖不如 CocoaPods 丰富 无法在 Xcode 里定位到源码 安装包的大小比用CocoaPods安装的包大 安装 使用 Homebrew 安装 Carthage. 安装 Homebrew Install Homebrew: 获取 Homebrew 最新版本$ brew update Homebrew 常用命令 搜索$ brew search &lt;packageName&gt; 安装$ brew install &lt;packageName&gt; 卸载$ brew uninstall &lt;packageName&gt; 查看已安装包列表$ brew list 查看包信息$ brew info &lt;packageName&gt; 查看Homebrew版本$ brew -v 安装 Cartgage 安装$ brew install carthage 查看 Cartgage 版本$ carthage version 更新 carthage 版本brew upgrade carthage 删除carthage旧版本brew cleanup carthage 使用 Cartgage 安装依赖 进入项目所在路径$ cd ~/路径/项目文件夹 创建空的 Carthage 文件 Cartfile$ touch Cartfile 使用 Xcode 打开 Cartfile 文件$ open -a Xcode Cartfile 编辑 Carfile 文件(以Alamofire为例)github &quot;Alamofire/Alamofire&quot; == 4.4.0 执行更新命令,获取类库$ carthage update --platform iOS 更新完成,检查目录结构更新完成后项目根路径会多出两个文件(Cartfile.resolved,Cartfile)和一个文件夹(Carthage), Carthage下又有两个文件夹(Checkouts 和 Build), Checkouts 从github获取的源代码, Build 编译出来的Framework二进制代码库. 添加 Frameworks 到项目中 点击’项目名’ –&gt; ‘TARGETS’ –&gt; ‘General’, 在最下边找到’Linked Framework and Libraries’. 点击’+’ –&gt; ‘Add Other ..’, 选择’Carthage/Build/iOS/Alamofire.framework’,点击 ‘Open’ 导入. 选择菜单选项 ‘Build Phases’ –&gt; 点击 ‘+’ –&gt; ‘New Run Script Phase’, 添加以下命令:/usr/local/bin/carthage copy-frameworks 点击 ‘Input Files’ 下的 ‘+’,为每个 Framework 添加访问路径:$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework 在项目中 import 所需包就可以使用了.import Alamofire]]></content>
      <categories>
        <category>Other</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTTCoder]]></title>
    <url>%2F2018%2F01%2F24%2FYTTCoder%2F</url>
    <content type="text"><![CDATA[最近工作之余对开发中用到的数据解析相关进行了整理,整合了开发中常用到的数据解析,并将其封装成模块.(持续完善中) YTTCoder : 实现常用的数据解析,例如: JSON 转 Model, 字典转 JSON等 YTTJsonCodable: JSON 与 Model 之间相互转化的工具类 提供数据转化的类方法,可直接调用. YTTJson: 协议,继承Codable协议 定义 Model 实体类只需遵守该协议即可调用装换方法. YTTArrayCoder: 数组扩展类 调用使用 obj.ytt.toJson() 形式调用 toJson: 数组转 JSON 字符串 YTTDictionaryCoder: 字典扩展类 调用使用 obj.ytt.toJson() 形式调用 toJson: 字典转 JSON 字符串 getValue(withKeyPath): 根据路径获取值 YTTStringCoder: 字符串扩展类 调用使用 obj.ytt.toDictionary() 形式调用 toDictionary: JSON 字符串转字典 toArray: JSON 字符串转数组 toDate: 时间字符串转 Date 对象 YTTDateCoder: Date 扩展类 调用使用 obj.ytt.toString() 形式调用 toString: Date 格式化 项目开发用到的解析文件 反馈如果您有什么好的修改建议,可以发邮件到AndyCuiYTT@163.com, 也欢迎到我的博客AndyCuiの博客一起讨论学习~]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑共同管理hexo博客]]></title>
    <url>%2F2017%2F10%2F20%2Fhexo-version-control%2F</url>
    <content type="text"><![CDATA[使用hexo搭建博客，如果换了电脑怎么更新博客？如果你有备份源文件那还好，但是每次都要备份感觉太麻烦了。这里介绍一种方法就是使用github分支。一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。网上也有其他的方法，大家可以去搜一下，自己看看哪种适合自己，我用这种方法一方面我git命令也不太熟，所以想多写写，多学学。 先删除主题文件下的.git文件，可以直接删除或者执行下面的命令 1$ rm -rf .git 然后在本地博客文件夹下边依次输入以下指令(部分指令因为有提示可以自己修改下) 123456$ git init$ git checkout -b hexo$ git remote add origin git@github.com:vonfly（你自己giuhub账号名）/vonfly.github.io（项目名）.git$ git add .$ git commit -m "提交说明"$ git push origin hexo 执行到这里我们就已经把本地的源文件添加到了分支hexo上。 说明：博客文件夹下根目录.gitignore（此文件的作用是因此忽略所写的文件或者目录，加快push速度。）可以不修改，我的就没有修改，如果不修改的话在；另外一台电脑上克隆下来的博客项目就要先运行一下命令 1$ npm install 我的.gitignore文件内容为.DS_StoreThumbs.dbdb.json.lognode_modules/public/.deploy/ 当然你也可以把node_modules/去掉，这样在另外的电脑克隆下来的项目就不用在运行上面的命令了 扩展： github常见操作和常见错误！如果输入$ git remote add origin git@github.com:vonfly（github帐号名）/vonfly.github.io（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下：1、先输入$ git remote rm origin2、再输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git 就不会报错了！ 如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！ 如果输入$ git push origin master提示出错信息：error:failed to push som refs to …….解决办法如下：1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来2、再输入$ git push origin master3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository.4、则需要重新输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SliderView]]></title>
    <url>%2F2017%2F10%2F14%2FSliderViews%2F</url>
    <content type="text"><![CDATA[SliderViews : 简单易用的滑动标签工具,『标签栏工具』『滑动视图工具』可单独使用. 安装1pod &apos;SliderViews&apos; 使用示例SegmentedView 使用 SegmentedView: 标签栏工具,使用需要实现 YTTSegmentedViewDelegate 代理方法. 123456789let segmented = YTTSegmentedView()segmented.delegate = self // 实现 YTTSegmentedViewDelegatesegmented.addTitleItems([&quot;SliderView1&quot;,&quot;SliderView2&quot;,&quot;SliderView3&quot;], isSelected: 1)segmented.backgroundColor = UIColor.cyanself.view.addSubview(segmented)segmented.snp.makeConstraints &#123; (make) in make.left.right.centerY.equalToSuperview() make.height.equalTo(50)&#125; SliderView 使用 SliderView: 滑动视图工具,使用需要实现YTTSliderViewDelegate代理 12345678910111213let sliderView = YTTSliderView()sliderView = self // 实现 YTTSliderViewDelegatelet view1 = UIView()view1.backgroundColor = UIColor.cyanlet view2 = UIView()view2.backgroundColor = UIColor.orangelet view3 = UIView()view3.backgroundColor = UIColor.bluesliderView.addChildViews([view1, view2, view3], isSelected: 1)self.view.addSubview(sliderView)sliderView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview()&#125; TabSliderView 使用 TabSliderView: SegmentedControl 与 SliderView 组合使用. 123456let tabSliderView = YTTTabSliderView()tabSliderView.addSubviews([(&quot;SliderView1&quot;,view1),(&quot;SliderView2&quot;,view2),(&quot;SliderView3&quot;,view3)])view.addSubview(tabSliderView)tabSliderView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview()&#125; 反馈如果您有什么好的修改建议,可以发邮件到AndyCuiYTT@163.com, 也欢迎到我的博客AndyCuiの博客一起讨论学习~]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>slider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 tableViewCell高度自适应]]></title>
    <url>%2F2017%2F08%2F01%2F%E6%B5%85%E8%B0%88-tableViewCell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[UITableView 是开发中最常用到的控件,可以说没有哪个 APP 离得开 UITableView 控件,使用时难免会遇到各种各样的问题,其中 cell 高度自适应是最让人头疼的,简单说一下我在开发中总结.开发中面对 cell 的自适应有着各种各样的方法,无外乎以下几种: 根据数据源计算 通常做法为自定义 cell 添加类方法,传入当前 cell 的数据源,计算除 cell 的高度,返回.然后在 tableView 的代理方法中设置 cell 高度.这种方法计算 cell 高度是需要注意:但计算 label 的高度时,要留意 label 的宽度和字体大小的设置,否则将会得到错误的高度 调用 tableView 的代理方法,拿到 cell 获取高度 这种做法的缺点使cell 的生成代码重复执行. iOS 8.0 以后可以与新引入 cell 自适应方法(在 xib 下使用) 需要设置 rowHeight( = UITableViewAutomaticDimension) 与 estimatedRowHeight 两个属性, rowHeight 设置表明使用自适应, estimatedRowHeight 一个参考值.使用自适应如果 cell 中有图片,最好对 ImageView 的宽高进行限定,否则适配将会根据图片大小自适应.当加载图片张数不确定时,可以添加一个 View, 在给 cell 赋值时用代码添加 ImgView, 将 view 的高度约束拖成属性,在图片添加完成后修改 view 的高度.]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>cell 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 打包 framework]]></title>
    <url>%2F2017%2F07%2F25%2Fswift-%E6%89%93%E5%8C%85-framework%2F</url>
    <content type="text"><![CDATA[在开发中我们常常会用到一些第三方 SDK 库，使用时只需将 framework 文件添加到项目中即可，十分方便。同样地，我们也可以创建自己的 framework 框架，用来封装一些常用的工具方法、框架类等。一来不会使源代码完全暴露在外，二来也便于代码复用。 打包篇 新建项目 选择 File-&gt;New-&gt;Project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework, 点击 Next,语言选择 swift 如图: 创建完成生成以下目录: xxx.h 文件的作用是整个包对外提供的入口头文件，除了正常定义参数属性之外还提供 Swift项目内引用的OC文件的import引用 info.plist 文件的作用就如同正常项目的plist文件作用，用来定义或添加一些属性。 添加文件 可以新建文件也可以在已有项目拷贝这里要注意一下：由于打包类库工程不是一个完整项目工程，所以并没有AppDelegate等文件，所以涉及到这些的文件要额外处理，或改代码，或适当改变功能。注意：工程如果有桥接文件，是不能拷贝过来的，否则编译不通过。桥接文件下的 import 引用应该放到 xxx.h 文件中注意: 如果 swift 文件想要暴露给外部使用,类及方法要用 public 修饰 经过以上操作本库已基本完成 注意: 如果用到资源文件,如:图片,视频,音频等直接用Assets.xcassets是无效的,我们要新建文件夹,将图片放入其中,添加后缀名.bundle,例如 xxx.bundle,使用图片时图片名:xxx.bundle/icon.png. 文件添加完毕就可以尝试 build 一下了 正常情况下，如果我们swift项目引入了oc文件，我们必须通过一个桥接文件来处理两者之间的转换，而我们在新建类库包的时候，是禁止桥接文件存在的，即使你添加了，也会永远编译不过，打包不了。所以这里就用到这个 xxx.h 头文件了。我们可以通过这个文件来实现两者之间的转换，前提就是必须先将oc的.h暴露出来，否则即使你import，也会报错找不到.h 文件。 暴露文件给外部使用 选择 target-&gt;Build Phases-&gt;Header, 将要暴露给外部使用OC 的.h 的文件拖到 public 下,如果是 swift 只需要将类和方法声明成 public 编译通过，查看这里 红框内就是最终我们得到的Framework包。右击本地查看，会看到本类库以及对应的依赖第三方库包，后面在其他项目引用的时候，这些都是需要的（需要一起拷贝添加）。 合并真机和模拟器framework 包的分类编译得到的包可分为 debug 包和 release包, debug 包一般用于测试,如果要发布务必打 release 包.release 包又包含模拟器包和真机包,发布时需要将模拟器包与真机包合并去包文件夹 合并包终端输入 lipo -create 真机路径 模拟器路径 -output 真机路径（ps：这几个路径就是上图拖动到终端后的路径）但是并没有完，不知道为什么，终端这样合并只是假象，你需要手动去将Modules里的的 xxx.swiftmodule文件合并到一起 引用篇 新建空白工程 将之前所得到 framework 拷贝到项目 在工程Targets－General－EmbeddedBinaries内添加Frameworks包 附加 引用 CommonCrypto项目中用到了 MD5加密, swift 是无法调用 C语言库的,在 xxx.h 中添加#import 报错,解决方法:新建 module.modulemap 文件,在里边添加1234 module CommonCrypto [system] &#123; header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/CommonCrypto/CommonCrypto.h" export *&#125; 选择 target-&gt;Build Settings, 找到 swift compler-Search Paths, 在 Import paths 添加创建文件路径在需要 MD5机密的文件中 import CommonCrypto 参考博客 iOS打包framework - Swift完整项目打包Framework，嵌入OC项目使用iOS打包Framework真机和模拟器兼容合并版本 - 详细攻略步骤]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 网络请求]]></title>
    <url>%2F2017%2F07%2F18%2Fnetwork-swift%2F</url>
    <content type="text"><![CDATA[对 Alamofire与系统的网络请求进行简易封装 Alamofire post 请求1234567891011121314151617/// post 请求////// 服务器端返回数据为 JSON 数据格式/// - Parameters:/// - urlStr: 请求网络地址/// - params: 请求参数/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_post(_ urlStr: String, _ params: ayParams? = nil, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void)&#123; Alamofire.request(urlStr, method: .post, parameters: params, encoding: URLEncoding.default, headers: nil).responseJSON &#123; (response) in if response.result.isSuccess&#123; result(response.result.value!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error"); &#125; &#125;&#125; get 请求1234567891011121314151617/// get 请求////// 服务器端返回数据为 JSON 数据格式/// - Parameters:/// - urlStr: 请求网络地址/// - params: 请求参数/// - result: 请求成功返回数据/// - fail: 请求失败返回数据static func ay_get(_ urlStr: String, _ params: ayParams? = nil, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void)&#123; Alamofire.request(urlStr, method: .get, parameters: params, encoding: URLEncoding.default, headers: nil).responseJSON &#123; (response) in if response.result.isSuccess&#123; result(response.result.value!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error"); &#125; &#125;&#125; 下载文件12345678910111213141516171819202122232425/// 下载文件////// - Parameters:/// - urlStr: 文件地址/// - method: 请求方式/// - param: 请求参数/// - fileURL: 保存文件路径/// - progress: 下载进度/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_downloadFile(_ urlStr: String, _ method: HTTPMethod? = .get, _ param: ayParams? = nil, fileURL: URL, progress: @escaping (Progress)-&gt;Void, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void) &#123; //拼接文件保存地址 let destination: DownloadRequest.DownloadFileDestination = &#123; _, response in return (fileURL.appendingPathComponent(response.suggestedFilename!), [.removePreviousFile, .createIntermediateDirectories]) &#125; Alamofire.download(urlStr, method: method!, parameters: param, encoding: URLEncoding.default, headers: nil, to: destination).downloadProgress(queue: DispatchQueue.main, closure: &#123; (progres) in progress(progres) &#125;).responseData&#123;(response) in if response.result.isSuccess &#123; result(response.destinationURL!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error") &#125; &#125;&#125; 文件上传123456789101112131415161718192021222324252627282930313233343536/// 文件上传////// 上传文件时注意文件名与 mimeType/// - Parameters:/// - urlStr: 上传地址/// - param: 上传参数/// - filesData: 上传数据数组 data 类型/// - progress: 上传进度/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_uploadFile(_ urlStr: String, _ param:ayParams? = nil,filesData: [Data], progress:@escaping (Progress)-&gt;Void, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void) &#123; Alamofire.upload(multipartFormData: &#123; (formData) in for data:Data in filesData &#123; formData.append(data, withName: "file", fileName: "fileName.png", mimeType: "image/png") &#125; if param != nil &#123; for (key , value) in param! &#123; formData.append(value.data(using: String.Encoding.utf8)!, withName: key) &#125; &#125; &#125;, to: urlStr) &#123; (encodingResult) in switch encodingResult&#123; case .success(request: let upload,_,_): upload.uploadProgress(closure: &#123; (progres) in progress(progres) &#125;) upload.responseJSON(completionHandler: &#123; (response) in if let value = response.result.value as? [String : AnyObject]&#123; result(value) &#125; &#125;) case .failure(let error): fail(error.localizedDescription) &#125; &#125;&#125; 系统网络请求 post 请求12345678910111213141516171819202122232425262728293031/// post 请求////// - Parameters:/// - urlStr: 请求地址/// - params: 请求参数/// - result: 返回结果/// - fail: 失败class func post(_ urlStr: String, params: [String : String], result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; var request = URLRequest.init(url: URL(string: urlStr)!) request.timeoutInterval = NetworkConfig.timeoutInterval request.httpMethod = "POST" var paramStr = String() for (key , value) in params &#123; paramStr.append("\(key)=\(value)&amp;") &#125; paramStr.remove(at: paramStr.index(before: paramStr.endIndex)) request.httpBody = paramStr.data(using: .utf8) let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; get 请求123456789101112131415161718192021222324252627282930/// get 请求////// - Parameters:/// - urlStr: 请求地址/// - params: 请求参数/// - result: 返回结果/// - fail: 失败class func get(_ urlStr: String, params: [String : String], result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; var paramStr = String() for (key , value) in params &#123; paramStr.append("\(key)=\(value)&amp;") &#125; paramStr.remove(at: paramStr.index(before: paramStr.endIndex)) var request = URLRequest.init(url: URL(string: urlStr + "?" + paramStr)!) request.timeoutInterval = NetworkConfig.timeoutInterval request.httpMethod = "GET" let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 文件下载123456789101112131415161718192021222324/// 文件下载////// - Parameters:/// - urlStr: 下载地址/// - fileName: 文件名/// - result: 文件缓存路径/// - fail: 失败class func download(_ urlStr: String, fileName: String, result: @escaping (String) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; let request = URLRequest.init(url: URL(string: urlStr)!) let session = URLSession(configuration: NetworkConfig.configuration) let task = session.downloadTask(with: request) &#123; (pathUrl, response, error) in if error == nil &#123; if let filePath: String = pathUrl?.path &#123; let fileManager = FileManager() try! fileManager.moveItem(atPath: filePath, toPath: NetworkConfig.downloadPath.appending(fileName)) try! fileManager.removeItem(atPath: filePath) result(NetworkConfig.downloadPath.appending(fileName)) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 仿 form 表单多文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 仿 form 表单多文件上传////// - Parameters:/// - urlStr: 上传文件路径/// - params: 请求参数/// - filesData: 文件数据/// - fileName: 文件名/// - fileExtensions: 文件扩展名/// - contentType: 文件类型/// - result: 返回数据/// - fail: 失败class func upload(_ urlStr: String, params: [String : String], filesData: [Data], fileName: String, fileExtensions:String, contentType: String,result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; let boundary = "*****" // 分界标识 var bodyData = Data() // 添加普通参数 for (key , value) in params &#123; bodyData.append("\r\n--\(boundary)\r\n".data(using: .utf8)!) bodyData.append("Content-Disposition:form-data;name=\"\(key)\"\r\n".data(using: .utf8)!) bodyData.append("Content-Type:text/plain;charset=utf-8\r\n\r\n".data(using: .utf8)!) bodyData.append("\(value)".data(using: .utf8)!) &#125; // 添加文件数据 for i in 0 ..&lt; filesData.count &#123; bodyData.append("\r\n--\(boundary)\r\n".data(using: .utf8)!) bodyData.append("Content-Disposition:form-data; name=\"file\";filename=\(fileName)-\(i).\(fileExtensions)\r\n".data(using: .utf8)!) bodyData.append("Content-Type: \(contentType)\r\n\r\n".data(using: .utf8)!) bodyData.append(filesData[i]) &#125; bodyData.append("\r\n--\(boundary)--\r\n".data(using: .utf8)!) // 设置 request var request = URLRequest(url: URL(string: urlStr)!) request.addValue("multipart/form-data;boundary=\"\(boundary)\";charset=\"UTF-8\"", forHTTPHeaderField: "Content-Type") request.addValue("\(bodyData.count)", forHTTPHeaderField: "Content-Length") request.httpMethod = "POST" request.httpBody = bodyData request.timeoutInterval = NetworkConfig.timeoutInterval // 发起请求 let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 添加网络数据缓存类 简述 网络请求缓存处理 将网络请求结果保存在本地，发起网路请求时先检测缓存区是否有缓存数据并判断是否超出缓存有效时间，如果数据有效则加载缓存区数据，否则加载网络数据. 数据缓存采用 SQLite 存储，采用 FMDB 库. 缓存数据表表数据有 key,value,date 三个字段. key: 网络请求参数 MD5加密数据. value:网络请求数据. date: 数据有效时间 添加计时器,定时清除无效数据. 主要方法1234567891011121314151617181920212223/// 获取数据////// - Parameter key: 键值/// - Returns: 数据func getResult(_ key: String) -&gt; String?/// 添加数据////// - Parameters:/// - key: 键值/// - result: 请求数据/// - date: 有效时间func addResult(_ key: String, result: String, date: TimeInterval) -&gt; Void/// 移除失效数据////// - Parameter date: 时间点func removeResult(withOldDate date: TimeInterval) -&gt; Void/// 根据 key 移除数据////// - Parameter key: 键值func removeResult(_ key: String) -&gt; Void 具体实现参考 Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝微信简单封装]]></title>
    <url>%2F2017%2F07%2F14%2FPayDemo%2F</url>
    <content type="text"><![CDATA[封装支付宝与微信支付,采用代理的方式接收支付结果. 支付宝支付 调起支付12345678/// 调起支付宝支付////// - Parameters:/// - orderinfo: 商品信息字符串/// - signedString: 商户信息签名/// - fromScheme: 应用注册scheme/// - resultDic: 支付结果回调func pay(_ orderinfo: String, signedString: String, fromScheme: String) -&gt; Void 支付结果回调,遵守 AlipayDelegate 协议12345678/// 支付成功func alipaySuccess(_ result: Any) -&gt; Void;/// 支付失败func alipayFail(_ result: Any) -&gt; Void;/// 支付取消func alipayCancel(_ result: Any) -&gt; Void;/// 其他未知错误func alipayUnknownError(_ result: Any) -&gt; Void; 微信支付 调起支付1234/// 微信支付////// - Parameter orderInfo: 支付信息(包含:partnerId,prepayId,package,nonceStr,timeStamp,sign等信息)func pay(_ orderInfo: [String : String]) -&gt; Void 微信支付 item appid: 应用ID(微信开放平台审核通过的应用APPID) partnerid: 商户号(微信支付分配的商户号) prepayid: 预支付交易会话ID(微信返回的支付交易会话ID) package: 扩展字段(只读) noncestr： 随机字符串（只读） timestamp： 时间撮（只读） getSignDic()： 获取签名后的字典 数据签名(获取签名字符串)1234567/// 获取签名字符串(MD5 签名)////// - Parameters:/// - orderInfo: 支付信息/// - keyStr: API密钥/// - Returns: 签名字符串func getSignStr(_ orderInfo: [String : String] ,keyStr: String) -&gt; String 支付结果回调,遵守 WeChatPayDelegate 协议12345678/// 微信未安装func WeChatPayWXAppUninstall() -&gt; Void;/// 支付成功func WeChatPaySuccess() -&gt; Void;/// 支付失败func WeChatPayFail(errStr: String) -&gt; Void;/// 支付取消func WeChatPayCancel() -&gt; Void; 具体实现参考 Demo]]></content>
      <categories>
        <category>iOS</category>
        <category>三方接入</category>
      </categories>
      <tags>
        <tag>pay</tag>
        <tag>alipay</tag>
        <tag>wechatpay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[swift] 星级评分]]></title>
    <url>%2F2017%2F07%2F13%2Fswift-%E6%98%9F%E7%BA%A7%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[许多App都会有评价功能，这个时候或许会需要实现星级评分，下面我们来简单的实现一个星级评分功能。 思路 通过添加图片形式实现星级打分功能.创建两个视图,其中一个添加灰色星星图片,另一个添加橘色星星图片.橘色星星视图覆盖灰色星星视图,通过修改橘色星星视图的宽度实现评分的展现. 创建一个继承于 UIView 的类,作为星级打分的显示视图 创建灰色星星视图,并添加到父视图. 创建橘色星星视图,添加到父视图,保证橘色视图覆盖灰色星星视图. 通过修改橘色星星视图宽度实现评分. 可通过手势等方式实现打分功能. 主要代码创建子视图代码:1234567891011121314private func ay_creatStartView(_ imageName: String) -&gt; UIView &#123; let starView = UIView(frame: CGRect(x: 0, y: 0, width: self.frame.width, height: self.frame.height)) starView.clipsToBounds = true starView.backgroundColor = UIColor.clear starView.isUserInteractionEnabled = false let imgViewWidth = (self.frame.width - CGFloat(totalStarNumber - 1) * 3) / CGFloat(totalStarNumber) for i in 0 ..&lt; totalStarNumber &#123; let imageView = UIImageView(image: UIImage(named: imageName)) imageView.frame = CGRect(x: CGFloat(i) * (imgViewWidth + 3), y: 0, width: imgViewWidth, height: self.frame.height) imageView.contentMode = .scaleAspectFit starView.addSubview(imageView) &#125; return starView &#125; 手指滑动打分代码123456789101112131415override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first let point = touch?.location(in: self) if (point?.x)! &gt;= CGFloat(0) &amp;&amp; (point?.x)! &lt;= self.frame.width &#123; rate = (point?.x)! / self.frame.width delegate?.ay_starRateChange(rate: rate) &#125; &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first let point = touch?.location(in: self) rate = (point?.x)! / self.frame.width delegate?.ay_starRateChange(rate: rate) &#125; 具体实现参考Demo 附加星级评分通过图片实现是最简单的办法,当然也可以通过其他方式实现.例如通过 UIBezierPath 绘制,具体可参考CPSliderView]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>自定义视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 UIBezierPath 与 CAShapeLayer 为 UIView 添加边框]]></title>
    <url>%2F2017%2F07%2F12%2Fswift%20%E9%80%9A%E8%BF%87-CGMutablePath-%E4%B8%BA-UIView-%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[通过贝塞尔曲线与 CAShapeLayer 为 View 添加虚线边框,可设置宽度,颜色,圆角等 代码如下: 123456789101112131415161718192021222324252627282930313233/// 为视图添加虚线边框 /// /// - Parameters: /// - view: 要添加边框的视图 /// - size: 视图 size /// - cornerRadius: 视图圆角 默认:10 /// - lineWidth: 边框宽 默认: 1 /// - lineColor: 边框颜色 默认: black /// - lineDashPattern: 边框段长和间距 默认: [5,3] func addBorderLine(view:UIView, size:CGSize, cornerRadius:CGFloat = 10, lineWidth:CGFloat = 1, lineColor:Color? = Color.black, lineDashPattern: [NSNumber] = [5,3]) -&gt; Void &#123; let shaplayer = CAShapeLayer() shaplayer.bounds = CGRect.init(x: 0, y: 0, width: size.width, height: size.height) shaplayer.anchorPoint = CGPoint.init(x: 0, y: 0) shaplayer.fillColor = Color.clear.cgColor shaplayer.strokeColor = lineColor?.cgColor shaplayer.lineWidth = lineWidth shaplayer.lineJoin = "miter" shaplayer.lineDashPattern = [5,3] let path = CGMutablePath() path.move(to: CGPoint.init(x: lineWidth / 2, y: cornerRadius + lineWidth / 2)) path.addArc(center: CGPoint.init(x: cornerRadius + lineWidth / 2, y: cornerRadius + lineWidth / 2), radius: cornerRadius, startAngle: .pi, endAngle: .pi / 2 * 3, clockwise: false) path.addLine(to: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: lineWidth / 2)) path.addArc(center: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: cornerRadius + lineWidth / 2), radius: cornerRadius, startAngle: .pi / 2 * 3, endAngle: .pi * 2, clockwise: false) path.addLine(to: CGPoint.init(x: size.width - lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2)) path.addArc(center: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2), radius: cornerRadius, startAngle: 0, endAngle: .pi / 2, clockwise: false) path.addLine(to: CGPoint.init(x: cornerRadius + lineWidth / 2, y: size.height - lineWidth / 2)) path.addArc(center: CGPoint.init(x: cornerRadius + lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2), radius: cornerRadius, startAngle: .pi / 2, endAngle: .pi, clockwise: false) path.addLine(to: CGPoint.init(x: lineWidth / 2, y: cornerRadius + lineWidth / 2)) shaplayer.path = path view.layer.addSublayer(shaplayer) view.layer.masksToBounds = true view.layer.cornerRadius = cornerRadius &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>UIBezierPath</tag>
        <tag>CAShapeLayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 调用系统自带导航功能实现]]></title>
    <url>%2F2017%2F06%2F18%2FiOS%20%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E5%AF%BC%E8%88%AA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[使用系统导航需要用到 MapKit 框架.通过调用 ‘MKMapItem.openMaps(with: [items], launchOptions: [options])’ 方法调起系统地图的导航功能.items 是一个数组,标记要经过的地方坐标 MKMapItem 类型,options 参数设置.具体使用如下:12345678910111213141516171819202122let startItem = MKMapItem(placemark: MKPlacemark(coordinate: CLLocationCoordinate2D(latitude: 36.7233600000, longitude: 116.9919300000), addressDictionary: nil))startItem.name = "济南百里黄河风景区" // 地址名let endItem = MKMapItem(placemark: MKPlacemark(coordinate: CLLocationCoordinate2D(latitude: 36.6709560000, longitude: 116.9908110000), addressDictionary: nil))endItem.name = "济南站" // 地址名endItem.phoneNumber = "0531-82422002" // 电话/*** key: MKLaunchOptionsDirectionsModeKey 导航模式* MKLaunchOptionsDirectionsModeDriving 汽车* MKLaunchOptionsDirectionsModeWalking 步行* MKLaunchOptionsDirectionsModeTransit 公交** key: MKLaunchOptionsMapTypeKey 地图类型* MKMapType 类型** key: MKLaunchOptionsShowsTrafficKey 是否显示详情按钮*/let options = [MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving, MKLaunchOptionsShowsTrafficKey: NSNumber(booleanLiteral: true), MKLaunchOptionsMapTypeKey: MKMapType.hybrid.rawValue] as [String : Any]MKMapItem.openMaps(with: [startItem, endItem], launchOptions: options)]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常阅读的博客]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%B8%B8%E9%98%85%E8%AF%BB%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我要申明，排名不分前后 iOSObjC 中国 bang’s blog 唐巧的技术博客 蘑菇街李忠 雷纯锋的技术博客 Sergio Chan 自己的博客 casa 的博客 冰霜的博客 串神的博客 南栀的博客 卓同学的博客 判若两人丶的博客 draveness 的博客 Other廖雪峰的官方网站 pandar’s blog]]></content>
      <categories>
        <category>Other</category>
        <category>阅读列表</category>
      </categories>
      <tags>
        <tag>Other</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 判断网络连接状态的几种方法]]></title>
    <url>%2F2016%2F09%2F11%2FiOS%20%E5%88%A4%E6%96%AD%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ReachabilityApple 的官方例子 Reachability 中介绍了获取、检测设备当前网络状态的方法。在你的程序中，需要把该工程中的Reachability.h 和 Reachability.m 拷贝到你的工程中，同时需要把 SystemConfiguration.framework 添加到工程中， 12345678910111213141516171819202122232425// 监听网络状态改变的通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkStateChange) name:kReachabilityChangedNotification object:nil];// 创建Reachabilityself.conn = [Reachability reachabilityForInternetConnection];// 开始监控网络(一旦网络状态发生改变, 就会发出通知kReachabilityChangedNotification)[self.conn startNotifier];// 处理网络状态改变- (void)networkStateChange &#123; // 1.检测wifi状态 Reachability *wifi = [Reachability reachabilityForLocalWiFi]; // 2.检测手机是否能上网络(WIFI\3G\2.5G) Reachability *conn = [Reachability reachabilityForInternetConnection]; // 3.判断网络状态 if ([wifi currentReachabilityStatus] != NotReachable) &#123; // 有wifi NSLog(@&quot;有wifi&quot;); &#125; else if ([conn currentReachabilityStatus] != NotReachable) &#123; // 没有使用wifi, 使用手机自带网络进行上网 NSLog(@&quot;使用手机自带网络进行上网&quot;); &#125; else &#123; // 没有网络 NSLog(@&quot;没有网络&quot;); &#125;&#125; AFNetwoking123456789101112131415161718192021222324252627// 1.获得网络监控的管理者AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];// 2.设置网络状态改变后的处理[mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;// 当网络状态改变了, 就会调用这个block switch (status) &#123; case AFNetworkReachabilityStatusUnknown: // 未知网络 NSLog(@&quot;未知网络&quot;); break; case AFNetworkReachabilityStatusNotReachable: // 没有网络(断网) NSLog(@&quot;没有网络(断网)&quot;); break; case AFNetworkReachabilityStatusReachableViaWWAN: // 手机自带网络 NSLog(@&quot;手机自带网络&quot;); break; case AFNetworkReachabilityStatusReachableViaWiFi: // WIFI NSLog(@&quot;WIFI&quot;); break; &#125;&#125;];// 3.开始监控[mgr startMonitoring]; Alamofire123456789101112131415161718private func monitorNetwork() &#123; if let manager = networkReachabilityManager &#123; networkReachabilityManager?.listener = &#123; (status) in switch status &#123; case .notReachable: // 无网络 case .reachable(NetworkReachabilityManager.ConnectionType.ethernetOrWiFi): // wifi case .reachable(NetworkReachabilityManager.ConnectionType.wwan): // 数据流量 default: // 未知 &#125; &#125; networkReachabilityManager?.startListening()&#125; 通过状态栏获取网络类型12345678910111213141516171819202122232425262728293031323334353637- (NSString *)getNetWorkStates&#123; UIApplication *app = [UIApplication sharedApplication]; NSArray *children = [[[app valueForKeyPath:@&quot;statusBar&quot;]valueForKeyPath:@&quot;foregroundView&quot;]subviews]; NSString *state = [[NSString alloc]init]; int netType = 0; //获取到网络返回码 for (id child in children) &#123; if ([child isKindOfClass:NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;)]) &#123; //获取到状态栏 netType = [[child valueForKeyPath:@&quot;dataNetworkType&quot;]intValue]; switch (netType) &#123; case 0: state = @&quot;无网络&quot;; //无网模式 break; case 1: state = @&quot;2G&quot;; break; case 2: state = @&quot;3G&quot;; break; case 3: state = @&quot;4G&quot;; break; case 5: &#123; state = @&quot;wifi&quot;; break; default: break; &#125; &#125; &#125; //根据状态选择 &#125; return state;&#125; 基本原理是从UIApplication类型中通过valueForKey获取内部属性 statusBar。然后筛选一个内部类型（UIStatusBarDataNetworkItemView），最后返回他的 dataNetworkType属性，根据状态栏获取网络状态，可以区分2G、3G、4G、WIFI，系统的方法，比较快捷，不好的是万一连接的WIFI 没有联网的话，识别不到。]]></content>
      <categories>
        <category>iOS</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>network</tag>
        <tag>Reachability</tag>
        <tag>AFNetwoking</tag>
        <tag>Alamofire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易音乐播放器制作]]></title>
    <url>%2F2016%2F04%2F20%2FiOS%20%E7%AE%80%E6%98%93%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[介绍1.功能:音乐列表,播放,暂停,上一曲,下一曲,进度条(显示进度时间,控制进度),随机播放,单曲循环,顺序播放,歌词显示等 2.使用框架:AVFoundation 3.知识点:AVPlayer 使用,pch 文件使用,封装思想,MVC模式,storyBoard的使用,消息发送机制,观察者,block回调,nstimer,nsrunloop,空间约束,第三方使用等 详细过程一.使用 storyBoard 布局1.歌曲列表界面:使用 TableViewController ,创建相应的 viewController , 继承于 UITableViewController ,与 storyBoard 控件相关联,实现相应方法 2.播放页面:添加相应控件,添加约束条件 , 创建相应的 viewController , 继承于 UIViewController ,与 storyBoard 控件相关联,实现相应方法 难点:播放图片与歌词页面 a.添加一个 ScrollView ,设置适当高度,宽度等于屏幕宽 b. 在ScrollView 添加一个 View ,与 Scroll 等高,宽度是 ScrollView 的两倍,距 ScrollView 上下左为零, c. 在 View 视图添加一个两个 UIView(播放和歌词页面) 子视图,播放页面距 view 上下左都为 0 ,宽度为屏幕宽,歌词页面距 view 页面上下右 都为 0,宽度为屏幕宽.在播放页面添加 imageView 作为播放图片显示,在歌词页面添加 tableView 作为歌词显示. 二.获取歌曲信息服务器端数据信息不规范,是 plist 文件,可以直接获取 array 形式. 三.对获取信息进行解析1.建立 Model ,在网络获取到的歌词是 NSString 类型,需要对其进行处理,转化为两个数组,一个存放歌词时间信息,一个存放歌词内容.使用到 NSString 的 componentsSeparatedByString 方法,把字符串根据某个字符切割转化为数据 2.把获取到的数据数组转化为 Model 数据 四.封装播放控制类1.使用单例:由于播放器在一个程序中只能有一个,如果过多会出现声音杂乱的情况. 2.应用 block :添加 bloak ,使得可以在 ViewController 可以通过回调控制视图. 3.添加监听:用来监听音乐的播放完成和音乐加载完成,实现其相应的操作. 12[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playToEnd) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];//监听音乐播放完成[playItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil];//监听音乐加载完成 4.应用NStimer , NSRunloop ,实现对播放的时时控制:使用回调控制 图片旋转,进度条,歌词滚动. 123self.timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(playTimer) userInfo:nil repeats:YES];//将定时器加入 runloop 中 [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; [self.timer fire]; 5.AVPlayer 知识点: a. AVPlayer 需要创建 AVPlayerItem ,数据的加载监听是对他的 status 属性德监听 b. 计算当前播放了多少秒 CGFloat timer = _avPlayer.currentTime.value / _avPlayer.currentTime.timescale; c. 获取歌曲总时长: _sumTime = self.avPlayer.currentItem.duration.value / self.avPlayer.currentItem.duration.timescale; d. 设置特定得时间播放点 self.avPlayer seekToTime:CMTimeMakeWithSeconds(timer * _sumTime, self.avPlayer.currentTime.timescale) completionHandler:^(BOOL finished) {}]; 五.对界面处理1234567891011121314难点:对歌词的处理 [self.lyricTableView selectRowAtIndexPath:[self lyricTableViewTime:timer] animated:YES scrollPosition:UITableViewScrollPositionMiddle];计算 IndexPath 方法:- (NSIndexPath*)lyricTableViewTime:(CGFloat)time&#123; for (int i = 0 ; i &lt; model.timerArray.count ; i++)&#123; CGFloat timeArray = [model.timerArray[i] AG_StringToTime]; if (time &lt; timeArray)&#123; return [NSIndexPath indexPathForItem:(i - 1 &gt; 0 ? i - 1 : 0) inSection:0]; &#125; &#125; return [NSIndexPath indexPathForItem:model.timerArray.count - 1 inSection:0];&#125; 使 cell 透明 : cell.backgroundColor = [UIColor clearColor];改变 cell 选中时的背景 : cell.selectedBackgroundView = view; 参考代码]]></content>
      <categories>
        <category>iOS</category>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CuiXg]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[基本资料 学历：本科 学校：德州学院 学院：信息管理学院 专业：计算机科学与技术 届别：2016届 联系方式 邮箱：AndyCuiYTT@163.com 博客：http://CuiXg.top github：https://github.com/andycuiytt]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
