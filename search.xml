<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UILabel 加载 HTML]]></title>
    <url>%2F2018%2F08%2F13%2FUILabel%E5%8A%A0%E8%BD%BDHTML%2F</url>
    <content type="text"><![CDATA[iOS 开发中为了开发方便时长会加载一些 HTML 静态页面,目前主要使用 UIWebView 与 WKWebView 进行加载,但仅仅作为页面展示我认为没有必要使用他们,且他们高度自适应比较繁琐,因此比较推荐使用 UILabel 加载富文本形式展现 HTML 页面. OC 代码12NSAttributedString * attrStr = [[NSAttributedString alloc] initWithData:[htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123; NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType &#125; documentAttributes:nil error:nil];label.attributedText = attrStr; swift 代码123if let data = htmlStr.data(using: String.Encoding.unicode), let attributedStr = try? NSAttributedString(data: data, options: [NSAttributedString.DocumentReadingOptionKey.documentType : NSAttributedString.DocumentType.html], documentAttributes: nil) &#123; label.attributedText = attributedStr&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>富文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIButton 设置图片与文字位置]]></title>
    <url>%2F2018%2F08%2F10%2FUIButton%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E4%B8%8E%E6%96%87%E5%AD%97%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[UIButton 可谓是 iOS 开发中使用频率最多的控件了,然而很多时候系统为我们提供的 UIButton 样式不能满足我们的需求,需要我们对样式进行调整,主要对文字图片的位置进行总结. 以 UIButton 为跟视图,添加 UIImageView 与 UILabel 优点: 处理简单,可以很便捷的进行布局. 缺点: UIButton 本身自带有 UIImageView 与 UILabel 控件,重复. 通过设置 titleEdgeInsets 与 imageEdgeInsets 属性 优点: 可以直接调整 UIButton 的 UIImageView 与 UILabel,不必再次添加. 确定: 便宜量计算比较复杂. 注意: 设置 titleEdgeInsets 与 imageEdgeInsets 属性并不会调整 UIButton, UIImageView, UILabel 的 frame, 如果偏移后超出父视图范围则不会响应. 自定义 UIButton新建 YTTCustomButton 类,继承与 UIButton, 通过重写 layoutSubviews 方法进行调整. imageAlignment属性: YTTButtonImageAlignment 类型 ( top, bottom, right, left 图片位置) spaceBetweenTitleAndImage: CGFloat 类型, 图片文字间距 CustomButton 下载]]></content>
      <categories>
        <category>iOS</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>自定义视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 忽略不必要提交的文件]]></title>
    <url>%2F2018%2F08%2F09%2Fgit%E5%BF%BD%E7%95%A5%E4%B8%8D%E5%BF%85%E8%A6%81%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在开发中版本控制是开发人员必不可少的,现在常用的版本控制主要是 git/svn.在实际开发过程中会产生一些中间文件或者项目中有些文件是不需要进行版本管理的,我们可以通过设置 .gitignore 文件忽略这些文件. 创建 .gitignore 文件 指定不需要提交的文件需要在版本管理根目录下创建 .gitignore (gitignore是隐藏文件，所以前面有个点), 与 .git 同级 进入版本管理文件夹: cd /Users/**/**/** 创建 .gitignore 文件: touch .gitignore 编辑 .gitignore 文件: vim .gitignore 编辑 .gitignore 文件忽略规则： ’#’是注释，将被git忽略。 可以使用Linux通配符。 如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略 如果名称的最前面有一个路径分隔符（/）,表示将忽略的文件在此目录下，而子目录中的文件不忽略 如果名称的最后面有一个路径分隔符（/）,表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略） gitignore 配置例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint## Obj-C/Swift specific*.hmap*.ipa*.dSYM.zip*.dSYM# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-controlPods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build# fastlane## It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the# screenshots whenever they are needed.# For more information about the recommended setup visit:# https://docs.fastlane.tools/best-practices/source-control/#source-controlfastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_output# Code Injection## After new code Injection tools there&apos;s a generated folder /iOSInjectionProject# https://github.com/johnno1962/injectionforxcodeiOSInjectionProject/# fastlanefastlane]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 总结]]></title>
    <url>%2F2018%2F06%2F21%2FiOS%20%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS是由苹果公司开发的移动操作系统. iOS 简介开发语言Object-C 通常写作ObjC或OC和较少用的Objective C或Obj-C，是扩充C的面向对象编程语言。OC 完全兼容 C语言. 面向对象语言(C 语言面向过程). 是MAC OSX和IOS开发的基础语言。 Swift 苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序. Swift和Objective-C共用一套运行时环境,项目中可以通过桥接的方式互相调用. 开发工具 Xcode: 运行在操作系统Mac OS X上的集成开发工具（IDE），由苹果公司开发。 iOS 基础APP 生命周期iOS 应用有5中状态: Not running 应用还没启动或正在运行但是中途被系统停止 Inactive 应用正在前台运行(不接收事件) Active 应用正在前台运行(接收事件) Background 应用处于后台运行(还在执行代码) Suspended 应用处于后台运行(停止执行代码)对应的函数:12345678910111213141516//应用将要进入非活动调用 (不接受消息或事件)- (void)applicationWillResignActive:(UIApplication *)application;//应用进入活动调用 (接收消息或事件)- (void)applicationDidBecomeActive:(UIApplication *)application;//应用进入后台调用 (设置后台继续运行)- (void)applicationDidEnterBackground:(UIApplication *)application;//应用将要进入前台调用- (void)applicationWillEnterForeground:(UIApplication *)application;//应用将要退出调用 (保存数据,退出前清理)- (void)applicationWillTerminate:(UIApplication *)application;//应用被终止前调用 (内存清理,方式应用被终止)- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application;//应用载入后调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;//应用打开URL时调用- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url; 内存管理机制(引用计数)简介OC 引入引用计数机制来跟踪并管理对象的生命周期.iOS 5之前采用 MRC(手动内存管理) 管理内存.需用开发人员手动调用reatain,release等方法.iOS 5之后采用 ARC(自动内存管理) 管理内存,不用开发人员去关心引用计数的变化. 操作 对应 OC 方法 引用计数变化 创建对象 alloc,new 等 生成对象,引用计数设置为 1 持有对象 reatain 引用计数 +1 释放对象 release 引用计数 -1 废弃对象 dealloc 引用计数为0,释放内存 alloc 与 dealloc,reatain与 release 成对存在, 谁创建谁释放，谁retain谁释放只有当引用计数为 0 是对象才会销毁回收内存. 工作原理 当我们创建(alloc)一个新对象A的时候，它的引用计数从零变为 1. 当有一个指针指向这个对象A，也就是某对象想通过引用保留(retain)该对象A时，引用计数加 1. 当某个指针/对象不再指向这个对象A，也就是释放(release)该引用后，我们将其引用计数减 1. 当对象A的引用计数变为 0 时，说明这个对象不再被任何指针指向(引用)了，这个时候我们就可以将对象A销毁，所占内存将被回收，且所有指向该对象的引用也都变得无效了。系统也会将其占用的内存标记为“可重用”(reuse). 属性声明@property(nonatomic, strong)UITextField *textField;OC 采用 ‘@property’ 声明对象, 会默认生成一个 ‘_textField’ 成员变量与与之对应的 ‘setter/getter’ 方法. 属性修饰符 修饰符 描述 引用计数变化 copy 复制,创建一个新对象,通常修饰 NSString,NSArray,NSDictionary,NSSet 新对象引用计数为 1,旧对象不变 retain 释放旧对象,主要用于(MRC) 释放旧对象,计数 -1,新对象 retain, 计数 +1 strong 强引用,与 retain相似 释放旧对象,计数 -1,新对象 retain, 计数 +1 assign 修饰基本数据类型 不变 weak 与assign类似,修饰对象,对消销毁后自动变成 nil,主要用于修饰 delegate 不变 readwrite 可读写,生成 setter 与 getter 方法 - readonly 只读,只为属性生成 getter 方法 - nonatomic 非原子属性,不为 setter 方式加锁,非线程安全,通常采用这种,执行效率高 - atomic 原子属性,为 setter 方式加锁,线程安全 - 注意问题 对 block 修饰 Strong,copy 都可以,建议使用 copy. block 声明默认为栈变量,为了能够在block的声明域外使用，所以要把block拷贝（copy）到堆，所以说为了block属性声明和实际的操作一致，最好声明为copy。 NSString,NSArray,NSDictionary,NSSet 建议使用 copy. 当将 NSMutableString 赋值给 NSString 时, strong 修饰只会进行浅拷贝(引用计数 +1),NSMutableString与NSString 指向同一内存空间,NSMutableString修改时NSString会随之改变. copy 修饰深拷贝(复制内存单元),NSMutableString与NSString 指向不同内存空间,NSMutableString修改时NSString不会改变. __weak __Strong __block 在 block 使用时有时为了避免造成循环引用会用 __weak __Strong 进行修饰下. 有时在 block 中,为了避免对象过早释放用 __Strong 修饰. 数据持久化 读写文件: 比较复杂,对对象保存需要进行归档反归档处理. 云端存储: 需要后台配合. 本地数据库(SQLite,CoreDate): CoreDate 是 iOS5 之后出现的,实质是对 SQLite 的封装. NSUserDefaults: 系统自带的持久化类,进行简单数据存储(用户登录信息等). 类继承关系(单继承)iOS 所有的类都继承与 NSObject, 主要分为 UI 和 NS 两大类. UI 主要为视图, NS 为数据操作.图解: 其他:UIViewController 生命周期: 初始化 –&gt; loadView –&gt; viewDidLoad –&gt; viewWillAppear –&gt; viewWillLayoutSubviews –&gt; viewDidLayoutSubviews –&gt; viewDidAppear –&gt; viewWillDisappear –&gt; viewDidDisappear –&gt; dealloc 传值 属性传值 block 传值 代理传值 通知传值 单例传值 持久化传值 协议与代理在iOS开发中，Protocol是一种经常用到的设计模式，苹果的系统框架中也普遍用到了这种方式,比如UITableView中的.协议声明:12345678910111213#import &lt;Foundation/Foundation.h&gt;@protocol ProtocolDelegate &lt;NSObject&gt;// 必须实现方法@required- (NSString*)getName;// 可选方法@optional- (NSString*)getAge;@end 协议使用 协议是一系列标准的方法列表，可以被任何类实现. 协议中不能声明成员变量，只要一个类遵守了这个协议，也相当于拥有了该协议中所有方法的声明. 父类遵守了该协议，那么它的子类也就都遵守该协议,可以遵守多个协议. 代理: 当前类(委托者)将一些操作委托给另一个类(代理)去完成.委托者需要做的事： 创建协议（也就是代理要实现的方法） 声明委托变量 设置代理（也可以在代理中设置） 利用委托变量来调用协议方法（也就是让代理者开始执行协议）代理需要做的事： 遵循协议 实现协议方法 数据请求iOS 中级响应者链 响应对象: 继承自UIResponder的对象称之为响应者对象. 响应事件: 触摸事件、点按事件(长按,多次点击,轻点等)、加速事件和远程控制. 响应者链: 由多个响应者组合起来的链条 事件产生与传递 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中. UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow). 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步. 找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理. 如果调用了[super touches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者，调用上一个响应者的touches….方法注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 事件响应 如果视图不响应事件，则将其传递给它的父视图 在最顶级的视图层次结构中，如果都不能处理收到的事件或消息，则其将事件或消息传递给UIWindow对象进行处理 如果UIWindow对象也不处理，则其将事件或消息传递给UIApplication对象处理 如果UIApplication也不能处理该事件或消息，则将该事件丢弃如何判断上一个响应者 如果当前这个view不是控制器的view, 那么它的父控件就是上一个响应者 如果当前这个view是控制器的view, 那么控制器就是上一个响应者 UIView不能接收触摸事件的情况 不允许交互: userInteractionEnabled = NO(eg: UIImageView) 隐藏 透明度: 透明度&lt;0.01 子视图超出了父视图区域 当前 View 被遮挡 分类(category)与类扩展(extension)分类 在不改变原类的基础上为一个类扩展方法. 主要用法为系统类扩展方法 不可添加成员变量. 如果要添加成员变量需要自己实现 setter 和 getter 方法(runtime). 分类文件(.h,.m),以为 Person 添加分类为例,可以通过 Person 实例对象直接调用 playFootBall 方法(分类方法执行优先级高于本类). Person+sport.h1234567#import "Person.h"@interface Person (sport)- (void)playFootBall;@end Person+sport.m123456789#import "Person+sport.h"@implementation Person (sport)- (void)playFootBall &#123; NSLog(@"playFootBall");&#125;@end 类扩展类扩展是分类的一个特例,为一个类添加一些私有成员变量和方法(常用).类扩展定义的方法，须在类的implement 中实现类扩展可以定义属性声明:12345#import "Person.h"@interface Person ()- (void)say;@end 分类与继承iOS 中分类(Categories) 和 继承(Inherit)有相同的功能，但在一些细节上又有差异，如何选择。使用继承: 扩展方法与原方法名相同,还需要使用父类方法. 扩展类属性(分类不能扩展类属性)使用分类: 为系统类添加方法(eg: 为 NSString 添加字符串校验). 开发人员针对自己的类,将相关方法分组到不同的文件. UITableView 重用机制UITableView 是 iOS 开发中最长用的控件,为了节省内存开销, UITableView 使用重用机制(重用 cell 单元格). 使用重用机制创建 cell 定义重用标示(static 修饰字符串). 在重用池取出 cell. 若重用池没有可用 cell, 创建新的 cell.12345static NSString *reuseIndentifier = @"MyCell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:reuseIndentifier]; &#125; 原理UITableView 维护这两个队列,单前可视 cell 队列 visiableCells, 可重用 cell 队列 reusableTableCells(重回池).在最初visiableCells, reusableTableCells 都为空, “UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@”cell”];” 获取 cell 为 nil, 执行 cell 初始化方法创建显示并存入到 visiableCells.如果屏幕最多显示 cell 个数为10,当加载完第11个 cell 时创建的第一个 cell 在 visiableCells 移除加入到 reusableTableCells 中,所以在加载第12个 cell 时只需在 reusableTableCells 取出 cell 即可.第十二个 cell 加载完成后创建的第二个 cell 移出 visiableCells 进入 reusableTableCells 中,依次类推(理论讲只需创建11个 cell 就可). 遇到问题和优化 重取出来的cell是有可能已经捆绑过数据或者加过子视图的，造成视图叠加混乱的现象 删除已有数据或子视图. 放弃了重用机制，每次根据indexPath获取对应的cell返回(内存销耗特大). 结合 MJFresh 实现数据分页加载. 结合 SDWebImage 实现 cell 中图片异步加载以及缓存. 常用三方库 库名 介绍 平台 网络请求 AFNetworking 轻量级网络请求开源框架 OC 网络请求 Alamofire swift 版 AFNetwoking swift 图片加载 SDWebImage 在网络下载并缓存图片 OC 图片加载 Kingfisher 在网络下载并缓存图片 swift 布局 Masonry 自动布局框架 OC 布局 SnapKit 自动布局框架 swift 加载 MJRefresh 下拉刷新框架 OC 模型转换 MJExtension json 转 model OC 模型转换 HandyJSON json 转 model swift]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS音视频播放]]></title>
    <url>%2F2018%2F06%2F16%2FiOS%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[按公司需求需要对音频文件进行后台播放,借此机会对音频播放做了个总结.主要针对 AVPlayer 进行详细说明. iOS 各播放器比较 名称 使用环境 优点 确点 System Sound Services AVFoundation C语言的底层写法，节省内存 支持的格式有限，音量无法通过音量键控制，而且播放方式单一。 AVAudioPlayer AVFoundation 抒写效率更高，基本上支持所有的音频格式，对播放的控制，如循环播放，声音大小，暂停等比较方便。 对内存的消耗会多些。不支持流式，即无法播放在线音乐。 AVPlayer AVFoundation 可以播放音视频,可播放在线音乐,使用灵活 MPMoviePlayerController MediaPlayer 简单易用 不可定制 AVPlayerViewController AVKit 简单易用 不可定制 IJKPlayer IJKMediaFramework 定制度高，支持流媒体播放 使用稍复杂 AVPlayer 使用简介AVPlayer 是iOS上常用的视频播放器组件，支持常见的音视频格式,支持流播放,可以播放在线音乐.支持视频格式： WMV，AVI，MKV，RMVB，RM，XVID，MP4，3GP，MPG等。支持音频格式：MP3，WMA，RM，ACC，OGG，APE，FLAC，FLV等。 相关类 AVPlayer：播放器,控制播放器的播放，暂停，播放速度. AVURLAsset : AVAsset 的一个子类，使用 URL 进行实例化，实例化对象包换 URL 对应视频资源的所有信息. AVPlayerItem：管理资源对象，提供播放数据源. AVPlayerLayer：负责显示视频，如果没有添加该类，只有声音没有画面. 简单使用使用 url 创建 AVPlayer1let player = AVPlayer(url: URL(string: "http://www.xxxx.mp3")) 使用 AVPlayerItem 创建 AVPlayer12345678910if let url = URL(string: "http://www.***.mp3") &#123; let asset = AVAsset(url: url) guard asset.isPlayable else&#123; // 检测文件是否可播放 return &#125; let playItem = AVPlayerItem(asset: asset) let player = AVPlayer(playerItem: playItem) player.play()&#125; AVPlayer 控制播放123player.play() // 播放player.pause() //暂停player.rate = 1.0 // 播放速度 通过通知监听播放状态变化123456789//播放完成AVPlayerItemDidPlayToEndTimeNotification//播放失败AVPlayerItemFailedToPlayToEndTimeNotification//异常中断AVPlayerItemPlaybackStalledNotification// eg: 播放结束通知NotificationCenter.default.addObserver(self, selector: #selector(finish(_:)), name: NSNotification.Name.AVPlayerItemDidPlayToEndTime, object: nil) 监听播放进度12345678// 添加周期时间观察者 一秒执行一次 blocklet timeObserver = player.addPeriodicTimeObserver(forInterval: CMTime(seconds: 1, preferredTimescale: 1), queue: DispatchQueue.main, using: &#123; [weak self] (cmTime) in if let totalTime = self?.currentPlayItem?.duration &#123; self?.delegate?.player(self!, currentTime: cmTime.seconds, totalTime: totalTime.seconds) &#125;&#125;)// 不要忘记移除player.removeTimeObserver(observer) AVPlayerItem 创建1234567891011121314// 使用 AVAsset 创建if let url = URL(string: "http://www.***.mp3") &#123; let asset = AVAsset(url: url) guard asset.isPlayable else&#123; // 检测文件是否可播放 return &#125; let playItem = AVPlayerItem(asset: asset)&#125;// 使用 URL 创建if let url = URL(string: "http://www.***.mp3") &#123; let playItem = AVPlayerItem(url: url)&#125; 监听 AVPlayerItem 状态和缓存进度12345678// 监听 playerItem 状态变化playItem.addObserver(self, forKeyPath: "status", options: .new, context: nil)// 监听缓存时间playItem.addObserver(self, forKeyPath: "loadedTimeRanges", options: .new, context: nil)// 移除监听currentPlayItem?.removeObserver(self, forKeyPath: "status")currentPlayItem?.removeObserver(self, forKeyPath: "loadedTimeRanges") 123456789101112131415161718192021222324override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if object is AVPlayerItem &#123; if keyPath == "status" &#123; if let playerItem = object as? AVPlayerItem &#123; switch playerItem.status &#123; case .readyToPlay: // 准备播放 case .failed: // 加载失败 default: // 未知状态 &#125; &#125; &#125; if keyPath == "loadedTimeRanges" &#123; if let playerItem = object as? AVPlayerItem &#123; if let timeRange = playerItem.loadedTimeRanges.first as? CMTimeRange &#123; let cache = timeRange.start.seconds + timeRange.duration.seconds // 缓存总时长 &#125; &#125; &#125; &#125; 音频后台播放开启所需后台模式选中Targets–&gt;Capabilities–&gt;BackgroundModes–&gt;ON,并勾选Audio and AirPlay选项，如下图:或者 plist 文件添加如下字段:利用 AVAudioSession 申请后台播放权限 1234567let session = AVAudioSession.sharedInstance()do &#123; try session.setActive(true) try session.setCategory(AVAudioSessionCategoryPlayback)&#125; catch &#123; print(error)&#125; 在播放控制界面接受远程控制(Remote Control)开启远程控制12// 声明接收Remote Control事件UIApplication.shared.beginReceivingRemoteControlEvents() 设置 Remote Control 响应12345// 响应 Remote Control事件MPRemoteCommandCenter.shared().playCommand.addTarget(self, action: #selector(play))MPRemoteCommandCenter.shared().nextTrackCommand.addTarget(self, action: #selector(next))MPRemoteCommandCenter.shared().pauseCommand.addTarget(self, action: #selector(pause))MPRemoteCommandCenter.shared().previousTrackCommand.addTarget(self, action: #selector(previous)) 移除 Remote Control 响应1234567// 在关闭播放页面时记得移除MPRemoteCommandCenter.shared().playCommand.removeTarget(self, action: #selector(play))MPRemoteCommandCenter.shared().nextTrackCommand.removeTarget(self, action: #selector(next))MPRemoteCommandCenter.shared().pauseCommand.removeTarget(self, action: #selector(pause))MPRemoteCommandCenter.shared().previousTrackCommand.removeTarget(self, action: #selector(previous))// 停止响应 Remote ControlUIApplication.shared.endReceivingRemoteControlEvents() 通过重写父类方法响应外部事件 开启接受远程控制 使当前页面成为第一响应者 重写 remoteControlReceivedWithEvent 方法. UIEvent Type 取值: UIEventSubtypeRemoteControlTogglePlayPause // 暂停 UIEventSubtypeRemoteControlPreviousTrack // 上一首 UIEventSubtypeRemoteControlNextTrack // 下一首 UIEventSubtypeRemoteControlPlay // 播放 UIEventSubtypeRemoteControlPause // 暂停 关闭接受远程控制 锁屏页面显示播放信息(Now Playing Center)使用 MPNowPlayingInfoCenter 设置锁屏页面音乐信息. 1234567891011121314func setLockScreenPlayingInfo(_ info: YTTMediaInfo) &#123; // Now Playing Center可以在锁屏界面展示音乐的信息，也达到增强用户体验的作用。 // https://www.jianshu.com/p/458b67f84f27 var infoDic: [String : Any] = [:] infoDic[MPMediaItemPropertyTitle] = info.title // 歌曲名 infoDic[MPMediaItemPropertyArtist] = info.singer // 歌手 if let img = info.image &#123; infoDic[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(image: img) // 专辑图片 &#125; infoDic[MPMediaItemPropertyPlaybackDuration] = info.totalTime // 歌曲总时长 infoDic[MPNowPlayingInfoPropertyElapsedPlaybackTime] = info.currentTime // 当前播放时间 infoDic[MPNowPlayingInfoPropertyPlaybackRate] = 1.0 // 播放速度 MPNowPlayingInfoCenter.default().nowPlayingInfo = infoDic&#125; 注意: MPNowPlayingInfoPropertyElapsedPlaybackTime 设置的并不是时时的,他是根据你设置的值进行计时的,如果想要在锁屏页面得到准确的时间,请及时刷新 MPNowPlayingInfoPropertyElapsedPlaybackTime 的值.当暂停时要暂停播放时间,只需将 MPNowPlayingInfoPropertyPlaybackRate 设置为 0.播放时设置回 1. 补充说明iOS 对后台管理十分严格,任何 app 都有大约3分钟或者10分钟的后台执行时间.3分钟或者10分钟后, app 就会被强制挂起.使用 AVAudioSession 申请后台权限时,可以保证播放本地音乐能在后台长久播放,当播放网络音乐时就会出现不能播放情况,针对这情况使用了 beginBackgroundTask 设置后台任务 ID,通过这种方式我们大约可以获得额外的 10 分钟来执行后台任务.为了能无限后台播放网络音乐添加计时器,当即将挂起时再次申请后台任务 ID. 1234567891011121314151617181920func applicationDidEnterBackground(_ application: UIApplication) &#123; // 这样做，可以在按home键进入后台后 ，播放一段时间，几分钟吧。但是不能持续播放网络歌曲，若需要持续播放网络歌曲，还需要申请后台任务id bgTask = application.beginBackgroundTask(expirationHandler: nil) timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(timerAction), userInfo: nil, repeats: true)&#125;@objc func timerAction() &#123; timerCount = timerCount + 1 if timerCount &lt; 500 &#123; return &#125; timerCount = 0 let newTask = UIApplication.shared.beginBackgroundTask(expirationHandler: nil) if bgTask != UIBackgroundTaskInvalid &amp;&amp; newTask != UIBackgroundTaskInvalid &#123; UIApplication.shared.endBackgroundTask(bgTask) bgTask = newTask &#125; &#125; 其他 AVPlayer那些坑 项目参考地址]]></content>
      <categories>
        <category>iOS</category>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发之 CoreData]]></title>
    <url>%2F2018%2F06%2F01%2FiOS%20%E5%BC%80%E5%8F%91%E4%B9%8B%20CoreData%2F</url>
    <content type="text"><![CDATA[简介CoreData 是苹果公司封装的进行数据持久化的框架,首次在 iOS3.0版本的系统中出现,它允许按照实体-属性-值模型组织数据,并以 XML, 二进制文件或者 SQLite 数据文件格式持久化数据. 优点 CoreData 是苹果公司原生态的产品是在 iOS3.0版本系统出现,是苹果大力推广的技术之一,可以实现对 XML, 二进制文件和 SQLite 数据文件的访问. 可以节省代码量,一般要节省30%到70%的代码量. 支持可视化建模. CoreData 支持模型版本升级等. 创建工程 创建 CoreData 项目,记住选中 “Use Core Data”.项目会自动创建出数据模型文件. 创建出项目会发现多了 CoreDataDemo.xcdatamodeld 模型文件(可视化建模文件) 主要类 NSManagedObjectContext: 被管理对象上下文(数据管理器). NSManagedObjectModel: 被管理对象(数据模型器). NSPersistentStoreCoordinator: 持久化存储助理(数据链接器). 创建模型 点击 “CoreDataDemo.xcdatamodeld” 文件,添加实体. 这里我们需要创建Person和Card的实体以及实体属性: 选中Person实体，在Person中添加card属性: 选中Card实体，在Card中添加person属性: 添加后模型对应关系: 数据操作 获取上下文对象,在创建项目时, AppDelegate 提供了相应方法获取上下文. 1234var context: NSManagedObjectContext = &#123; let appDelegate = UIApplication.shared.delegate as! AppDelegate return appDelegate.persistentContainer.viewContext&#125;() 查询 123456789101112131415161718@IBAction func selected(_ sender: UIButton) &#123; let request = NSFetchRequest&lt;NSFetchRequestResult&gt;() request.entity = NSEntityDescription.entity(forEntityName: "Person", in: context) request.predicate = NSPredicate(format: "age=%@", "26") request.sortDescriptors = [NSSortDescriptor(key: "age", ascending: true)] do &#123; let result = try context.fetch(request) if let person = result as? [Person] &#123; for per in person &#123; print("\(per.name) : \(per.age) ---- \(per.card?.no) : \(per.card?.name)") &#125; &#125; &#125; catch &#123; print(error) &#125;&#125; 添加 1234567891011121314151617// 添加@IBAction func insert(_ sender: UIButton) &#123; let person = NSEntityDescription.insertNewObject(forEntityName: "Person", into: context) person.setValue(nameText.text, forKey: "name") person.setValue(Int(ageText.text!), forKey: "age") let card = NSEntityDescription.insertNewObject(forEntityName: "Card", into: context) card.setValue("123456", forKey: "no") card.setValue("学生卡", forKey: "name") person.setValue(card, forKey: "card") do &#123; try context.save() &#125;catch &#123; print(error) &#125;&#125; 修改 12345678910111213141516171819/// 修改数据////// - 修改数据要查询出需要修改的数据,依次修改@IBAction func update(_ sender: UIButton) &#123; let request = NSFetchRequest&lt;NSFetchRequestResult&gt;() request.entity = NSEntityDescription.entity(forEntityName: "Person", in: context) request.predicate = NSPredicate(format: "age=%@", "26") do &#123; let result = try context.fetch(request) if let person = result as? [Person] &#123; for per in person &#123; per.name = "Angelo" try context.save() &#125; &#125; &#125; catch &#123; print(error) &#125;&#125; 删除 12345678910111213141516171819/// 删除数据////// - 删除数据需要先查询出要删除的数据,依次删除@IBAction func deleter(_ sender: UIButton) &#123; let request = NSFetchRequest&lt;NSFetchRequestResult&gt;() request.entity = NSEntityDescription.entity(forEntityName: "Person", in: context) request.predicate = NSPredicate(format: "age=%@", "26") do &#123; let result = try context.fetch(request) if let person = result as? [Person] &#123; for per in person &#123; context.delete(per) &#125; &#125; &#125; catch &#123; print(error) &#125;&#125; GitHub 地址:https://github.com/AndyCuiYTT/CoreDataDemo]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>CoreData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 沙盒机制]]></title>
    <url>%2F2018%2F05%2F31%2FiOS%20%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[iOS 每个 APP 都有自己的存储空间,这个存储空间叫做沙盒. APP可以在自己的沙盒中进行数据存取操作,但不能访问其他 app 的沙盒空间.对 app 做一些数据存储或者文件缓存时,一般都保存在沙盒中. 沙盒机制简介目录结构沙盒机制根据访问权限和功能区别分为不同的目录: document,library,temp,.app, library又包含 caches 和preferences. document: 保存应用运行时生成的需要持久化的数据iTunes会自动备份该目录。苹果建议将在应用程序中浏览到的文件数据保存在该目录下. library: 这个目录下有两个目录 caches: 一般存储的是缓存文件，例如图片视频等，此目录下的文件不会再应用程序退出时删除，在手机备份的时候，iTunes不会备份该目录。 preferences: 保存应用程序的所有偏好设置iOS的Settings(设置)，我们不应该直接在这里创建文件，而是需要通过NSUserDefault这个类来访问应用程序的偏好设置。iTunes会自动备份该文件目录下的内容. temp: 临时文件目录，在程序重新运行的时候，和开机的时候，会清空tmp文件夹。 .app: 这个就是可运行的应用文件，带有签名的文件包，包含应用程序代码和静态数据. 特点 每个应用程序都在自己的沙盒内. 不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容. 应用程序向外请求或接收数据都需要经过权限认证. 沙盒操作获取沙盒路径获取沙盒根路径1let homePath = NSHomeDirectory() 获取 document 路径1let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) 获取 library 路径1let libraryPath = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true) 获取 cache 路径1let cachePath = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) 获取 preferences 路径由系统维护,不需要我们手动获取文件目录.可借助 UserDefault 维护 获取 tmp 路径1let tmpPath = NSTemporaryDirectory() 获取程序目录和内容 获取程序包路径let path = Bundle.main.resourcePath 获取图片资源路径let imagePath = Bundle.main.path(forResource: &quot;temp&quot;, ofType: &quot;png&quot;) 文件管理iOS 对文件进行管理需要用到文件管理器: FileManager. 检测文件是否存在FileManager.default.fileExists(atPath: filePath) 创建文件路径FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil) 创建文件FileManager.default.createFile(atPath: path, contents: data, attributes: nil) 文件删除FileManager.default.removeItem(atPath: path) 文件移动FileManager.default.moveItem(atPath: oldPath, toPath: newPath) 文件复制FileManager.default.copyItem(atPath: oldPath, toPath: newPath) 获取文件属性FileManager.default.attributesOfItem(atPath: filePath)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现 cell 加载网络图片自适应方案]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%AE%9E%E7%8E%B0cell%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[UITableView 是 iOS 开发中最常用的控件之一,使用 UITaleView 时最头疼的莫过于 cell 高度的计算,虽说在 iOS8.0 以后引入了自适应方法,但在适配过程中任然会遇到各种难题,尤其是为了满足产品需求进行复杂 cell 自定义时,高度计算可谓是难上加难.这里主要对开发中遇到的自定义 cell 是加载网络图片适配问题进行总结. 在开发中为了用户能有更好体验,对网络请求多采用异步请求的方式,更有甚者对请求数据做了本地缓存.图片作为 app 中最常见的展现形式无疑是最耗流量的,对图片的处理直接影响到用户的体验,好在有大神为我们提供了好的框架(Kingfisher,SDWebImage),大大提高了我们的开发效率. 图片的异步加载提高了用户体验,却在开发中遇到了新的难题,因为图片异步加载你无法提前预知图片的尺寸,在布局时难以控制 UIImageView 的大小,如果将 UIImageView 固定大小势必会造成图片的压缩或拉伸,现在主要针对于自定义 cell 时对图片自适应布局提一些建议. 固定 UIImageView 大小在开发中我们时常会将 UIImageView 固定大小或者固定宽高比例,通过设置 ImageView 的 contentMode 属性设置图片的显示风格.该方法简单容易造成图片压缩拉伸或显示不全问题.contentMode 取值: 12345678910111213141516171819202122232425262728public enum UIViewContentMode : Int &#123; case scaleToFill //缩放内容到合适比例大小 case scaleAspectFit //缩放内容到合适的大小，边界多余部分透明 case scaleAspectFill //缩放内容填充到指定大小，边界多余的部分省略 case redraw //重绘视图边界 case center //视图保持等比缩放,居中 case top //视图顶部对齐 case bottom //视图底部对齐 case left //视图左侧对齐 case right //视图右侧对齐 case topLeft //视图左上角对齐 case topRight //视图右上角对齐 case bottomLeft //视图左下角对齐 case bottomRight //视图右下角对齐&#125; 通过获取服务器存储的图片尺寸布局在上传图片时可以将图片的大小一起上传服务器保存,在用户加载图片时将图片信息和图片 URL 地址一起返回,根据返回的图片信息计算 UIImageView 的 size 进行布局.该方法比较简单,但需要后台配合使用. 通过监听图片加载刷新 cell 实现(配合 cell 自适应)无论 SDWebiamge 还是 Kingfisher,作者都给我们提供了图片加载完回调方法,我们可以在图片加载完后重新计算 cell 高度.该方法大大加大了 cell 的刷新频率.具体步骤: 在自定义 cell 中定义闭包变量.var refreshCell: ((IndexPath) -&gt; Void)? 在图片加载完成的回调中调用闭包,为了减少 cell 的刷新,判断是拉取网络数据还是加载的缓存数据,如果是网络数据调整图片大小并将调整后图片覆盖网络加载图片,如果是缓存图片不处理. 1234567iconImageView.kf.setImage(with: URL(string: iconImageURL), placeholder: UIImage(named: "tmp")) &#123; [weak self](image, error, type, url) in if type == .none &#123; self?.iconImageView.image = self?.iconImageView.image?.ytt.resetImageSizeWithWidth(UIScreen.main.bounds.width) ImageCache.default.store((image?.ytt.resetImageSizeWithWidth(UIScreen.main.bounds.width))!, forKey: (url?.absoluteString)!) self?.refreshCell?(indexPath) &#125;&#125; 在 TableView 回调方法中实现闭包,仅当 cell 展现在屏幕时刷新 12345cell.refreshCell = &#123;(index) in if (tableView.indexPathsForVisibleRows?.contains(index))! &#123; tableView.reloadRows(at: [index], with: .automatic) &#125;&#125; 通过 ImageIO 框架获取图片信息在给 UIImageView 赋值时通过 ImageIO 获取 image 的尺寸,修改 UIImageView 的大小.该方法需要在网络请求数据,加大了数据请求量.实现代码:123456789let imageSource = CGImageSourceCreateWithURL(URL(string: iconImageURL)! as CFURL, nil)if let result = CGImageSourceCopyPropertiesAtIndex(imageSource!, 0, nil) as? Dictionary&lt;String, Any&gt; &#123; if let width = result["PixelWidth"] as? CGFloat, let height = result["PixelHeight"] as? CGFloat &#123; let h = (UIScreen.main.bounds.width - 20) / (width / height) iconImageView.snp.remakeConstraints &#123; (make) in make.height.equalTo(h) &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>cell 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carthage 安装以及初步实用]]></title>
    <url>%2F2018%2F05%2F22%2FCarthage%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本人从事 iOS 开发已有2年多,用 swift 开发也有一年多的时间了,此前一直利用 cocopods 管理三方框架和依赖,最近了解到 Carthage 这个工具,本着学习的态度对这工具进行了了解. 官方地址: https://github.com/Carthage/Carthage Carthage 简介 Carthage 类似于 CocoaPods，为用户管理第三方框架和依赖，但不会自动修改项目文件和生成配置 Carthage 是去中心化的依赖管理工具，安装依赖时不需要去中心仓库获取 CocoaPods 所有依赖的索引，节省时间 对项目无侵入性，Carthage 设计上也比较简单，利用的都是 Xcode 自身的功能，开发者在创建依赖时，相比 CocoaPods 也简单许多 Carthage 管理的依赖只需编译一次，项目干净编译时，不会再去重新编译依赖，节省时间 自动将第三方框架编程为 Dynamic framework( 动态库 )与 CocoaPods 无缝集成，一个项目能同时拥有 CocoaPods 和 Carthage 缺点： 仅支持 iOS8 + 它只支持框架，所以不能用来针对 iOS 8 以前的系统版本进行开发支持的 Carthage 安装的第三方框架和依赖不如 CocoaPods 丰富 无法在 Xcode 里定位到源码 安装包的大小比用CocoaPods安装的包大 安装 使用 Homebrew 安装 Carthage. 安装 Homebrew Install Homebrew: 获取 Homebrew 最新版本$ brew update Homebrew 常用命令 搜索$ brew search &lt;packageName&gt; 安装$ brew install &lt;packageName&gt; 卸载$ brew uninstall &lt;packageName&gt; 查看已安装包列表$ brew list 查看包信息$ brew info &lt;packageName&gt; 查看Homebrew版本$ brew -v 安装 Cartgage 安装$ brew install carthage 查看 Cartgage 版本$ carthage version 更新 carthage 版本brew upgrade carthage 删除carthage旧版本brew cleanup carthage 使用 Cartgage 安装依赖 进入项目所在路径$ cd ~/路径/项目文件夹 创建空的 Carthage 文件 Cartfile$ touch Cartfile 使用 Xcode 打开 Cartfile 文件$ open -a Xcode Cartfile 编辑 Carfile 文件(以Alamofire为例)github &quot;Alamofire/Alamofire&quot; == 4.4.0 执行更新命令,获取类库$ carthage update --platform iOS 更新完成,检查目录结构更新完成后项目根路径会多出两个文件(Cartfile.resolved,Cartfile)和一个文件夹(Carthage), Carthage下又有两个文件夹(Checkouts 和 Build), Checkouts 从github获取的源代码, Build 编译出来的Framework二进制代码库. 添加 Frameworks 到项目中 点击’项目名’ –&gt; ‘TARGETS’ –&gt; ‘General’, 在最下边找到’Linked Framework and Libraries’. 点击’+’ –&gt; ‘Add Other ..’, 选择’Carthage/Build/iOS/Alamofire.framework’,点击 ‘Open’ 导入. 选择菜单选项 ‘Build Phases’ –&gt; 点击 ‘+’ –&gt; ‘New Run Script Phase’, 添加以下命令:/usr/local/bin/carthage copy-frameworks 点击 ‘Input Files’ 下的 ‘+’,为每个 Framework 添加访问路径:$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework 在项目中 import 所需包就可以使用了.import Alamofire]]></content>
      <categories>
        <category>Other</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTTCoder]]></title>
    <url>%2F2018%2F01%2F24%2FYTTCoder%2F</url>
    <content type="text"><![CDATA[最近工作之余对开发中用到的数据解析相关进行了整理,整合了开发中常用到的数据解析,并将其封装成模块.(持续完善中) YTTCoder : 实现常用的数据解析,例如: JSON 转 Model, 字典转 JSON等 YTTJsonCodable: JSON 与 Model 之间相互转化的工具类 提供数据转化的类方法,可直接调用. YTTJson: 协议,继承Codable协议 定义 Model 实体类只需遵守该协议即可调用装换方法. YTTArrayCoder: 数组扩展类 调用使用 obj.ytt.toJson() 形式调用 toJson: 数组转 JSON 字符串 YTTDictionaryCoder: 字典扩展类 调用使用 obj.ytt.toJson() 形式调用 toJson: 字典转 JSON 字符串 getValue(withKeyPath): 根据路径获取值 YTTStringCoder: 字符串扩展类 调用使用 obj.ytt.toDictionary() 形式调用 toDictionary: JSON 字符串转字典 toArray: JSON 字符串转数组 toDate: 时间字符串转 Date 对象 YTTDateCoder: Date 扩展类 调用使用 obj.ytt.toString() 形式调用 toString: Date 格式化 反馈如果您有什么好的修改建议,可以发邮件到AndyCuiYTT@163.com, 也欢迎到我的博客AndyCuiの博客一起讨论学习~]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑共同管理hexo博客]]></title>
    <url>%2F2017%2F10%2F20%2Fhexo-version-control%2F</url>
    <content type="text"><![CDATA[使用hexo搭建博客，如果换了电脑怎么更新博客？如果你有备份源文件那还好，但是每次都要备份感觉太麻烦了。这里介绍一种方法就是使用github分支。一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。网上也有其他的方法，大家可以去搜一下，自己看看哪种适合自己，我用这种方法一方面我git命令也不太熟，所以想多写写，多学学。 先删除主题文件下的.git文件，可以直接删除或者执行下面的命令 1$ rm -rf .git 然后在本地博客文件夹下边依次输入以下指令(部分指令因为有提示可以自己修改下) 123456$ git init$ git checkout -b hexo$ git remote add origin git@github.com:vonfly（你自己giuhub账号名）/vonfly.github.io（项目名）.git$ git add .$ git commit -m "提交说明"$ git push origin hexo 执行到这里我们就已经把本地的源文件添加到了分支hexo上。 说明：博客文件夹下根目录.gitignore（此文件的作用是因此忽略所写的文件或者目录，加快push速度。）可以不修改，我的就没有修改，如果不修改的话在；另外一台电脑上克隆下来的博客项目就要先运行一下命令 1$ npm install 我的.gitignore文件内容为.DS_StoreThumbs.dbdb.json.lognode_modules/public/.deploy/ 当然你也可以把node_modules/去掉，这样在另外的电脑克隆下来的项目就不用在运行上面的命令了 扩展： github常见操作和常见错误！如果输入$ git remote add origin git@github.com:vonfly（github帐号名）/vonfly.github.io（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下：1、先输入$ git remote rm origin2、再输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git 就不会报错了！ 如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！ 如果输入$ git push origin master提示出错信息：error:failed to push som refs to …….解决办法如下：1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来2、再输入$ git push origin master3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository.4、则需要重新输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SliderView]]></title>
    <url>%2F2017%2F10%2F14%2FSliderViews%2F</url>
    <content type="text"><![CDATA[SliderViews : 简单易用的滑动标签工具,『标签栏工具』『滑动视图工具』可单独使用. 安装1pod &apos;SliderViews&apos; 使用示例SegmentedControl 使用 SegmentedControl: 标签栏工具,使用需要实现 YTTSegmentedDelegate 代理方法. 123456789let segmented = YTTSegmentedControl()segmented.delegate = self // 实现 YTTSegmentedDelegatesegmented.addTitleItems([&quot;SliderView1&quot;,&quot;SliderView2&quot;,&quot;SliderView3&quot;], isSelected: 1)segmented.backgroundColor = UIColor.cyanself.view.addSubview(segmented)segmented.snp.makeConstraints &#123; (make) in make.left.right.centerY.equalToSuperview() make.height.equalTo(50)&#125; SliderView 使用 SliderView: 滑动视图工具,使用需要实现YTTSliderViewDelegate代理 12345678910111213let sliderView = YTTSliderView()sliderView = self // 实现 YTTSliderViewDelegatelet view1 = UIView()view1.backgroundColor = UIColor.cyanlet view2 = UIView()view2.backgroundColor = UIColor.orangelet view3 = UIView()view3.backgroundColor = UIColor.bluesliderView.addChildViews([view1, view2, view3], isSelected: 1)self.view.addSubview(sliderView)sliderView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview()&#125; TabSliderView 使用 TabSliderView: SegmentedControl 与 SliderView 组合使用. 123456let tabSliderView = YTTTabSliderView()tabSliderView.addSubviews([(&quot;SliderView1&quot;,view1),(&quot;SliderView2&quot;,view2),(&quot;SliderView3&quot;,view3)])view.addSubview(tabSliderView)tabSliderView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview()&#125; 反馈如果您有什么好的修改建议,可以发邮件到AndyCuiYTT@163.com, 也欢迎到我的博客AndyCuiの博客一起讨论学习~]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>slider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift处理JSON - 转换JSON和Model]]></title>
    <url>%2F2017%2F08%2F29%2FSwift%E5%A4%84%E7%90%86JSON%20-%20%E8%BD%AC%E6%8D%A2JSON%E5%92%8CModel%2F</url>
    <content type="text"><![CDATA[背景&emsp;&emsp;很多时候我们再服务端请求下来的数据都是JSON格式，我们需要将这些数据展示在UI界面。我们一般都会先将JSON转化为数据模型或字典进行使用。&emsp;&emsp;为了更快的开发我们时常会用到一些开源库，其中JSON解析的库必不可少，在OC开发中我们常用的JSON解析库如MJExtension，JSONModel等,这些库基本都是利用runtime实现读取属性并利用kvc赋值的。在swift中由于runtime的局限性，产生了一些通过反射等机制实现的库，比如SwiftyJSON，ObjectMapper，HandyJSON等，而 HandyJSON 是其中使用最舒服的一个库，本文将介绍用 HandyJSON 来进行Model和JSON间的互相转换。 简单示例反序列化1234567891011121314class BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String! required init() &#123;&#125;&#125;let jsonString = "&#123;\"doubleOptional\":1.1,\"stringImplicitlyUnwrapped\":\"hello\",\"int\":1&#125;"if let object = BasicTypes.deserialize(from: jsonString) &#123; print(object.int) print(object.doubleOptional!) print(object.stringImplicitlyUnwrapped)&#125; 序列化12345678let object = BasicTypes()object.int = 1object.doubleOptional = 1.1object.stringImplicitlyUnwrapped = “hello"print(object.toJSON()!) // serialize to dictionaryprint(object.toJSONString()!) // serialize to JSON stringprint(object.toJSONString(prettyPrint: true)!) // serialize to pretty JSON string 文档目录 特性 环境要求 安装 反序列化 基本类型 支持struct 支持enum 可选、隐式解包可选、集合等 指定解析路径 组合对象 继承自父类的子类 JSON中的数组 自定义解析规则 排除指定属性 支持的属性类型 序列化 基本类型 自定义映射和排除型 待办 特性 序列化Model到JSON、从JSON反序列化到Model 自然地以Model的属性名称作为解析JSON的Key，不需要额外指定 支持Swift中大部分类型 支持class、struct定义的Model 支持自定义解析规则 类型自适应，如JSON中是一个Int，但对应Model是String字段，会自动完成转化 具体支持的类型，可以参考代码文件: BasicTypes。 环境要求 iOS 8.0+/OSX 10.9+/watchOS 2.0+/tvOS 9.0+ Swift 2.3+ / Swift 3.0+ 安装HandyJSON只在Swift3.x版本上(master分支)开发新特性，在Swift2.x中使用，参见: swift2 branch 具体操作指引参考 英文版README 的 Installation 章节。 反序列化基本类型要支持从JSON串反序列化，Model定义时要声明服从HandyJSON协议。确实是一个协议，而不是继承自NSObject。 服从HandyJSON协议，需要实现一个空的init方法。 123456789101112class BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String! required init() &#123;&#125;&#125;let jsonString = "&#123;\"doubleOptional\":1.1,\"stringImplicitlyUnwrapped\":\"hello\",\"int\":1&#125;"if let object = BasicTypes.deserialize(from: jsonString) &#123; // …&#125; 支持struct对于声明为struct的Model，由于struct默认提供了空的init方法，所以不需要额外声明。 12345678910struct BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String!&#125;let jsonString = "&#123;\"doubleOptional\":1.1,\"stringImplicitlyUnwrapped\":\"hello\",\"int\":1&#125;"if let object = BasicTypes.deserialize(from: jsonString) &#123; // …&#125; 但需要注意，如果你为struct指定了别的构造函数，那就要显示声明一个空的init函数。 支持enum支持值类型的enum，且需要声明服从HandyJSONEnum协议。不再需要其他特殊处理了。 123456789101112131415enum AnimalType: String, HandyJSONEnum &#123; case Cat = "cat" case Dog = "dog" case Bird = "bird"&#125;struct Animal: HandyJSON &#123; var name: String? var type: AnimalType?&#125;let jsonString = "&#123;\"type\":\"cat\",\"name\":\"Tom\"&#125;"if let animal = Animal.deserialize(from: jsonString) &#123; print(animal.type?.rawValue)&#125; 可选、隐式解包可选、集合等HandyJSON支持这些非基础类型，包括嵌套结构。 123456789101112131415161718192021222324252627282930313233class BasicTypes: HandyJSON &#123; var bool: Bool = true var intOptional: Int? var doubleImplicitlyUnwrapped: Double! var anyObjectOptional: Any? var arrayInt: Array&lt;Int&gt; = [] var arrayStringOptional: Array&lt;String&gt;? var setInt: Set&lt;Int&gt;? var dictAnyObject: Dictionary&lt;String, Any&gt; = [:] var nsNumber = 2 var nsString: NSString? required init() &#123;&#125;&#125;let object = BasicTypes()object.intOptional = 1object.doubleImplicitlyUnwrapped = 1.1object.anyObjectOptional = "StringValue"object.arrayInt = [1, 2]object.arrayStringOptional = ["a", "b"]object.setInt = [1, 2]object.dictAnyObject = ["key1": 1, "key2": "stringValue"]object.nsNumber = 2object.nsString = "nsStringValue"let jsonString = object.toJSONString()!if let object = BasicTypes.deserialize(from: jsonString) &#123; // ...&#125; 指定解析路径HandyJSON支持指定从哪个具体路径开始解析，反序列化到Model。 123456789101112class Cat: HandyJSON &#123; var id: Int64! var name: String! required init() &#123;&#125;&#125;let jsonString = "&#123;\"code\":200,\"msg\":\"success\",\"data\":&#123;\"cat\":&#123;\"id\":12345,\"name\":\"Kitty\"&#125;&#125;&#125;"if let cat = Cat.deserialize(from: jsonString, designatedPath: "data.cat") &#123; print(cat.name)&#125; 组合对象注意，如果Model的属性不是基本类型或集合类型，那么它必须是一个服从HandyJSON协议的类型。 如果是泛型集合类型，那么要求泛型实参是基本类型或者服从HandyJSON协议的类型。 1234567891011121314151617181920class Component: HandyJSON &#123; var aInt: Int? var aString: String? required init() &#123;&#125;&#125;class Composition: HandyJSON &#123; var aInt: Int? var comp1: Component? var comp2: Component? required init() &#123;&#125;&#125;let jsonString = "&#123;\"num\":12345,\"comp1\":&#123;\"aInt\":1,\"aString\":\"aaaaa\"&#125;,\"comp2\":&#123;\"aInt\":2,\"aString\":\"bbbbb\"&#125;&#125;"if let composition = Composition.deserialize(from: jsonString) &#123; print(composition)&#125; 继承自父类的子类如果子类要支持反序列化，那么要求父类也服从HandyJSON协议。 123456789101112131415161718class Animal: HandyJSON &#123; var id: Int? var color: String? required init() &#123;&#125;&#125;class Cat: Animal &#123; var name: String? required init() &#123;&#125;&#125;let jsonString = "&#123;\"id\":12345,\"color\":\"black\",\"name\":\"cat\"&#125;"if let cat = Cat.deserialize(from: jsonString) &#123; print(cat)&#125; JSON数组如果JSON的第一层表达的是数组，可以转化它到一个Model数组。 12345678910111213class Cat: HandyJSON &#123; var name: String? var id: String? required init() &#123;&#125;&#125;let jsonArrayString: String? = "[&#123;\"name\":\"Bob\",\"id\":\"1\"&#125;, &#123;\"name\":\"Lily\",\"id\":\"2\"&#125;, &#123;\"name\":\"Lucy\",\"id\":\"3\"&#125;]"if let cats = [Cat].deserialize(from: jsonArrayString) &#123; cats.forEach(&#123; (cat) in // ... &#125;)&#125; 自定义解析规则HandyJSON支持自定义映射关系，或者自定义解析过程。你需要实现一个可选的mapping函数，在里边实现NSString值(HandyJSON会把对应的JSON字段转换为NSString)转换为你需要的字段类型。 12345678910111213141516171819202122232425262728293031323334class Cat: HandyJSON &#123; var id: Int64! var name: String! var parent: (String, String)? required init() &#123;&#125; func mapping(mapper: HelpingMapper) &#123; // specify 'cat_id' field in json map to 'id' property in object mapper &lt;&lt;&lt; self.id &lt;-- "cat_id" // specify 'parent' field in json parse as following to 'parent' property in object mapper &lt;&lt;&lt; self.parent &lt;-- TransformOf&lt;(String, String), String&gt;(fromJSON: &#123; (rawString) -&gt; (String, String)? in if let parentNames = rawString?.characters.split(separator: "/").map(String.init) &#123; return (parentNames[0], parentNames[1]) &#125; return nil &#125;, toJSON: &#123; (tuple) -&gt; String? in if let _tuple = tuple &#123; return "\(_tuple.0)/\(_tuple.1)" &#125; return nil &#125;) &#125;&#125;let jsonString = "&#123;\"cat_id\":12345,\"name\":\"Kitty\",\"parent\":\"Tom/Lily\"&#125;"if let cat = Cat.deserialize(from: jsonString) &#123; print(cat.id) print(cat.parent)&#125; 排除指定属性如果在Model中存在因为某些原因不能实现HandyJSON协议的非基本字段，或者不能实现HandyJSONEnum协议的枚举字段，又或者说不希望反序列化影响某个字段，可以在mapping函数中将它排除。如果不这么做，可能会出现未定义的行为。 1234567891011121314151617181920212223class NotHandyJSONType &#123; var dummy: String?&#125;class Cat: HandyJSON &#123; var id: Int64! var name: String! var notHandyJSONTypeProperty: NotHandyJSONType? var basicTypeButNotWantedProperty: String? required init() &#123;&#125; func mapping(mapper: HelpingMapper) &#123; mapper &gt;&gt;&gt; self.notHandyJSONTypeProperty mapper &gt;&gt;&gt; self.basicTypeButNotWantedProperty &#125;&#125;let jsonString = "&#123;\"name\":\"cat\",\"id\":\"12345\"&#125;"if let cat = Cat.deserialize(from: jsonString) &#123; print(cat)&#125; 支持的属性类型 Int/Bool/Double/Float/String/NSNumber/NSString NSArray/NSDictionary Int8/Int16/Int32/Int64/UInt8/UInt16/UInt23/UInt64 Optional&lt;T&gt;/ImplicitUnwrappedOptional&lt;T&gt; // T is one of the above types Array&lt;T&gt; // T is one of the above types Dictionary&lt;String, T&gt; // T is one of the above types 以上类型的嵌套 序列化基本类型现在，序列化也要求Model声明服从HandyJSON协议。 12345678910111213141516class BasicTypes: HandyJSON &#123; var int: Int = 2 var doubleOptional: Double? var stringImplicitlyUnwrapped: String! required init() &#123;&#125;&#125;let object = BasicTypes()object.int = 1object.doubleOptional = 1.1object.stringImplicitlyUnwrapped = “hello"print(object.toJSON()!) // serialize to dictionaryprint(object.toJSONString()!) // serialize to JSON stringprint(object.toJSONString(prettyPrint: true)!) // serialize to pretty JSON string 自定义映射和排除和反序列化一样，只要定义mapping和exclude就可以了。被排除的属性，序列化和反序列化都不再影响到它。而在mapping中定义的Transformer，同时定义了序列化和反序列的规则，所以只要为属性指明一个Transformer关系就可以了。 附加提供几个 JSON 字符串生成 model 类的工具： JSONExport iOS Code Generator D3Json JSONUtilities]]></content>
      <categories>
        <category>iOS</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>model</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 tableViewCell高度自适应]]></title>
    <url>%2F2017%2F08%2F01%2F%E6%B5%85%E8%B0%88-tableViewCell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[UITableView 是开发中最常用到的控件,可以说没有哪个 APP 离得开 UITableView 控件,使用时难免会遇到各种各样的问题,其中 cell 高度自适应是最让人头疼的,简单说一下我在开发中总结.开发中面对 cell 的自适应有着各种各样的方法,无外乎以下几种: 根据数据源计算 通常做法为自定义 cell 添加类方法,传入当前 cell 的数据源,计算除 cell 的高度,返回.然后在 tableView 的代理方法中设置 cell 高度.这种方法计算 cell 高度是需要注意:但计算 label 的高度时,要留意 label 的宽度和字体大小的设置,否则将会得到错误的高度 调用 tableView 的代理方法,拿到 cell 获取高度 这种做法的缺点使cell 的生成代码重复执行. iOS 8.0 以后可以与新引入 cell 自适应方法(在 xib 下使用) 需要设置 rowHeight( = UITableViewAutomaticDimension) 与 estimatedRowHeight 两个属性, rowHeight 设置表明使用自适应, estimatedRowHeight 一个参考值.使用自适应如果 cell 中有图片,最好对 ImageView 的宽高进行限定,否则适配将会根据图片大小自适应.当加载图片张数不确定时,可以添加一个 View, 在给 cell 赋值时用代码添加 ImgView, 将 view 的高度约束拖成属性,在图片添加完成后修改 view 的高度.]]></content>
      <categories>
        <category>iOS</category>
        <category>TableView</category>
      </categories>
      <tags>
        <tag>cell 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 打包 framework]]></title>
    <url>%2F2017%2F07%2F25%2Fswift-%E6%89%93%E5%8C%85-framework%2F</url>
    <content type="text"><![CDATA[在开发中我们常常会用到一些第三方 SDK 库，使用时只需将 framework 文件添加到项目中即可，十分方便。同样地，我们也可以创建自己的 framework 框架，用来封装一些常用的工具方法、框架类等。一来不会使源代码完全暴露在外，二来也便于代码复用。 打包篇 新建项目 选择 File-&gt;New-&gt;Project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework, 点击 Next,语言选择 swift 如图: 创建完成生成以下目录: xxx.h 文件的作用是整个包对外提供的入口头文件，除了正常定义参数属性之外还提供 Swift项目内引用的OC文件的import引用 info.plist 文件的作用就如同正常项目的plist文件作用，用来定义或添加一些属性。 添加文件 可以新建文件也可以在已有项目拷贝这里要注意一下：由于打包类库工程不是一个完整项目工程，所以并没有AppDelegate等文件，所以涉及到这些的文件要额外处理，或改代码，或适当改变功能。注意：工程如果有桥接文件，是不能拷贝过来的，否则编译不通过。桥接文件下的 import 引用应该放到 xxx.h 文件中注意: 如果 swift 文件想要暴露给外部使用,类及方法要用 public 修饰 经过以上操作本库已基本完成 注意: 如果用到资源文件,如:图片,视频,音频等直接用Assets.xcassets是无效的,我们要新建文件夹,将图片放入其中,添加后缀名.bundle,例如 xxx.bundle,使用图片时图片名:xxx.bundle/icon.png. 文件添加完毕就可以尝试 build 一下了 正常情况下，如果我们swift项目引入了oc文件，我们必须通过一个桥接文件来处理两者之间的转换，而我们在新建类库包的时候，是禁止桥接文件存在的，即使你添加了，也会永远编译不过，打包不了。所以这里就用到这个 xxx.h 头文件了。我们可以通过这个文件来实现两者之间的转换，前提就是必须先将oc的.h暴露出来，否则即使你import，也会报错找不到.h 文件。 暴露文件给外部使用 选择 target-&gt;Build Phases-&gt;Header, 将要暴露给外部使用OC 的.h 的文件拖到 public 下,如果是 swift 只需要将类和方法声明成 public 编译通过，查看这里 红框内就是最终我们得到的Framework包。右击本地查看，会看到本类库以及对应的依赖第三方库包，后面在其他项目引用的时候，这些都是需要的（需要一起拷贝添加）。 合并真机和模拟器framework 包的分类编译得到的包可分为 debug 包和 release包, debug 包一般用于测试,如果要发布务必打 release 包.release 包又包含模拟器包和真机包,发布时需要将模拟器包与真机包合并去包文件夹 合并包终端输入 lipo -create 真机路径 模拟器路径 -output 真机路径（ps：这几个路径就是上图拖动到终端后的路径）但是并没有完，不知道为什么，终端这样合并只是假象，你需要手动去将Modules里的的 xxx.swiftmodule文件合并到一起 引用篇 新建空白工程 将之前所得到 framework 拷贝到项目 在工程Targets－General－EmbeddedBinaries内添加Frameworks包 附加 引用 CommonCrypto项目中用到了 MD5加密, swift 是无法调用 C语言库的,在 xxx.h 中添加#import 报错,解决方法:新建 module.modulemap 文件,在里边添加1234 module CommonCrypto [system] &#123; header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/CommonCrypto/CommonCrypto.h" export *&#125; 选择 target-&gt;Build Settings, 找到 swift compler-Search Paths, 在 Import paths 添加创建文件路径在需要 MD5机密的文件中 import CommonCrypto 参考博客 iOS打包framework - Swift完整项目打包Framework，嵌入OC项目使用iOS打包Framework真机和模拟器兼容合并版本 - 详细攻略步骤]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 网络请求]]></title>
    <url>%2F2017%2F07%2F18%2Fnetwork-swift%2F</url>
    <content type="text"><![CDATA[对 Alamofire与系统的网络请求进行简易封装 Alamofire post 请求1234567891011121314151617/// post 请求////// 服务器端返回数据为 JSON 数据格式/// - Parameters:/// - urlStr: 请求网络地址/// - params: 请求参数/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_post(_ urlStr: String, _ params: ayParams? = nil, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void)&#123; Alamofire.request(urlStr, method: .post, parameters: params, encoding: URLEncoding.default, headers: nil).responseJSON &#123; (response) in if response.result.isSuccess&#123; result(response.result.value!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error"); &#125; &#125;&#125; get 请求1234567891011121314151617/// get 请求////// 服务器端返回数据为 JSON 数据格式/// - Parameters:/// - urlStr: 请求网络地址/// - params: 请求参数/// - result: 请求成功返回数据/// - fail: 请求失败返回数据static func ay_get(_ urlStr: String, _ params: ayParams? = nil, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void)&#123; Alamofire.request(urlStr, method: .get, parameters: params, encoding: URLEncoding.default, headers: nil).responseJSON &#123; (response) in if response.result.isSuccess&#123; result(response.result.value!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error"); &#125; &#125;&#125; 下载文件12345678910111213141516171819202122232425/// 下载文件////// - Parameters:/// - urlStr: 文件地址/// - method: 请求方式/// - param: 请求参数/// - fileURL: 保存文件路径/// - progress: 下载进度/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_downloadFile(_ urlStr: String, _ method: HTTPMethod? = .get, _ param: ayParams? = nil, fileURL: URL, progress: @escaping (Progress)-&gt;Void, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void) &#123; //拼接文件保存地址 let destination: DownloadRequest.DownloadFileDestination = &#123; _, response in return (fileURL.appendingPathComponent(response.suggestedFilename!), [.removePreviousFile, .createIntermediateDirectories]) &#125; Alamofire.download(urlStr, method: method!, parameters: param, encoding: URLEncoding.default, headers: nil, to: destination).downloadProgress(queue: DispatchQueue.main, closure: &#123; (progres) in progress(progres) &#125;).responseData&#123;(response) in if response.result.isSuccess &#123; result(response.destinationURL!) &#125;else&#123; fail(response.error?.localizedDescription ?? "Error") &#125; &#125;&#125; 文件上传123456789101112131415161718192021222324252627282930313233343536/// 文件上传////// 上传文件时注意文件名与 mimeType/// - Parameters:/// - urlStr: 上传地址/// - param: 上传参数/// - filesData: 上传数据数组 data 类型/// - progress: 上传进度/// - result: 成功返回数据/// - fail: 失败返回数据static func ay_uploadFile(_ urlStr: String, _ param:ayParams? = nil,filesData: [Data], progress:@escaping (Progress)-&gt;Void, result: @escaping (Any)-&gt;Void, fail: @escaping (Any)-&gt;Void) &#123; Alamofire.upload(multipartFormData: &#123; (formData) in for data:Data in filesData &#123; formData.append(data, withName: "file", fileName: "fileName.png", mimeType: "image/png") &#125; if param != nil &#123; for (key , value) in param! &#123; formData.append(value.data(using: String.Encoding.utf8)!, withName: key) &#125; &#125; &#125;, to: urlStr) &#123; (encodingResult) in switch encodingResult&#123; case .success(request: let upload,_,_): upload.uploadProgress(closure: &#123; (progres) in progress(progres) &#125;) upload.responseJSON(completionHandler: &#123; (response) in if let value = response.result.value as? [String : AnyObject]&#123; result(value) &#125; &#125;) case .failure(let error): fail(error.localizedDescription) &#125; &#125;&#125; 系统网络请求 post 请求12345678910111213141516171819202122232425262728293031/// post 请求////// - Parameters:/// - urlStr: 请求地址/// - params: 请求参数/// - result: 返回结果/// - fail: 失败class func post(_ urlStr: String, params: [String : String], result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; var request = URLRequest.init(url: URL(string: urlStr)!) request.timeoutInterval = NetworkConfig.timeoutInterval request.httpMethod = "POST" var paramStr = String() for (key , value) in params &#123; paramStr.append("\(key)=\(value)&amp;") &#125; paramStr.remove(at: paramStr.index(before: paramStr.endIndex)) request.httpBody = paramStr.data(using: .utf8) let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; get 请求123456789101112131415161718192021222324252627282930/// get 请求////// - Parameters:/// - urlStr: 请求地址/// - params: 请求参数/// - result: 返回结果/// - fail: 失败class func get(_ urlStr: String, params: [String : String], result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; var paramStr = String() for (key , value) in params &#123; paramStr.append("\(key)=\(value)&amp;") &#125; paramStr.remove(at: paramStr.index(before: paramStr.endIndex)) var request = URLRequest.init(url: URL(string: urlStr + "?" + paramStr)!) request.timeoutInterval = NetworkConfig.timeoutInterval request.httpMethod = "GET" let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 文件下载123456789101112131415161718192021222324/// 文件下载////// - Parameters:/// - urlStr: 下载地址/// - fileName: 文件名/// - result: 文件缓存路径/// - fail: 失败class func download(_ urlStr: String, fileName: String, result: @escaping (String) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; let request = URLRequest.init(url: URL(string: urlStr)!) let session = URLSession(configuration: NetworkConfig.configuration) let task = session.downloadTask(with: request) &#123; (pathUrl, response, error) in if error == nil &#123; if let filePath: String = pathUrl?.path &#123; let fileManager = FileManager() try! fileManager.moveItem(atPath: filePath, toPath: NetworkConfig.downloadPath.appending(fileName)) try! fileManager.removeItem(atPath: filePath) result(NetworkConfig.downloadPath.appending(fileName)) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 仿 form 表单多文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 仿 form 表单多文件上传////// - Parameters:/// - urlStr: 上传文件路径/// - params: 请求参数/// - filesData: 文件数据/// - fileName: 文件名/// - fileExtensions: 文件扩展名/// - contentType: 文件类型/// - result: 返回数据/// - fail: 失败class func upload(_ urlStr: String, params: [String : String], filesData: [Data], fileName: String, fileExtensions:String, contentType: String,result: @escaping (Any) -&gt; Void, fail: @escaping (Any) -&gt; Void) &#123; let boundary = "*****" // 分界标识 var bodyData = Data() // 添加普通参数 for (key , value) in params &#123; bodyData.append("\r\n--\(boundary)\r\n".data(using: .utf8)!) bodyData.append("Content-Disposition:form-data;name=\"\(key)\"\r\n".data(using: .utf8)!) bodyData.append("Content-Type:text/plain;charset=utf-8\r\n\r\n".data(using: .utf8)!) bodyData.append("\(value)".data(using: .utf8)!) &#125; // 添加文件数据 for i in 0 ..&lt; filesData.count &#123; bodyData.append("\r\n--\(boundary)\r\n".data(using: .utf8)!) bodyData.append("Content-Disposition:form-data; name=\"file\";filename=\(fileName)-\(i).\(fileExtensions)\r\n".data(using: .utf8)!) bodyData.append("Content-Type: \(contentType)\r\n\r\n".data(using: .utf8)!) bodyData.append(filesData[i]) &#125; bodyData.append("\r\n--\(boundary)--\r\n".data(using: .utf8)!) // 设置 request var request = URLRequest(url: URL(string: urlStr)!) request.addValue("multipart/form-data;boundary=\"\(boundary)\";charset=\"UTF-8\"", forHTTPHeaderField: "Content-Type") request.addValue("\(bodyData.count)", forHTTPHeaderField: "Content-Length") request.httpMethod = "POST" request.httpBody = bodyData request.timeoutInterval = NetworkConfig.timeoutInterval // 发起请求 let session = URLSession(configuration: NetworkConfig.configuration) let task = session.dataTask(with: request) &#123; (data, response, error) in if error == nil &#123; if let value = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) &#123; result(value) &#125;else &#123; result (String.init(data: data!, encoding: .utf8)!) &#125; &#125;else &#123; fail(error.debugDescription) &#125; &#125; task.resume()&#125; 添加网络数据缓存类 简述 网络请求缓存处理 将网络请求结果保存在本地，发起网路请求时先检测缓存区是否有缓存数据并判断是否超出缓存有效时间，如果数据有效则加载缓存区数据，否则加载网络数据. 数据缓存采用 SQLite 存储，采用 FMDB 库. 缓存数据表表数据有 key,value,date 三个字段. key: 网络请求参数 MD5加密数据. value:网络请求数据. date: 数据有效时间 添加计时器,定时清除无效数据. 主要方法1234567891011121314151617181920212223/// 获取数据////// - Parameter key: 键值/// - Returns: 数据func getResult(_ key: String) -&gt; String?/// 添加数据////// - Parameters:/// - key: 键值/// - result: 请求数据/// - date: 有效时间func addResult(_ key: String, result: String, date: TimeInterval) -&gt; Void/// 移除失效数据////// - Parameter date: 时间点func removeResult(withOldDate date: TimeInterval) -&gt; Void/// 根据 key 移除数据////// - Parameter key: 键值func removeResult(_ key: String) -&gt; Void 具体实现参考 Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝微信简单封装]]></title>
    <url>%2F2017%2F07%2F14%2FPayDemo%2F</url>
    <content type="text"><![CDATA[封装支付宝与微信支付,采用代理的方式接收支付结果. 支付宝支付 调起支付12345678/// 调起支付宝支付////// - Parameters:/// - orderinfo: 商品信息字符串/// - signedString: 商户信息签名/// - fromScheme: 应用注册scheme/// - resultDic: 支付结果回调func pay(_ orderinfo: String, signedString: String, fromScheme: String) -&gt; Void 支付结果回调,遵守 AlipayDelegate 协议12345678/// 支付成功func alipaySuccess(_ result: Any) -&gt; Void;/// 支付失败func alipayFail(_ result: Any) -&gt; Void;/// 支付取消func alipayCancel(_ result: Any) -&gt; Void;/// 其他未知错误func alipayUnknownError(_ result: Any) -&gt; Void; 微信支付 调起支付1234/// 微信支付////// - Parameter orderInfo: 支付信息(包含:partnerId,prepayId,package,nonceStr,timeStamp,sign等信息)func pay(_ orderInfo: [String : String]) -&gt; Void 微信支付 item appid: 应用ID(微信开放平台审核通过的应用APPID) partnerid: 商户号(微信支付分配的商户号) prepayid: 预支付交易会话ID(微信返回的支付交易会话ID) package: 扩展字段(只读) noncestr： 随机字符串（只读） timestamp： 时间撮（只读） getSignDic()： 获取签名后的字典 数据签名(获取签名字符串)1234567/// 获取签名字符串(MD5 签名)////// - Parameters:/// - orderInfo: 支付信息/// - keyStr: API密钥/// - Returns: 签名字符串func getSignStr(_ orderInfo: [String : String] ,keyStr: String) -&gt; String 支付结果回调,遵守 WeChatPayDelegate 协议12345678/// 微信未安装func WeChatPayWXAppUninstall() -&gt; Void;/// 支付成功func WeChatPaySuccess() -&gt; Void;/// 支付失败func WeChatPayFail(errStr: String) -&gt; Void;/// 支付取消func WeChatPayCancel() -&gt; Void; 具体实现参考 Demo]]></content>
      <categories>
        <category>iOS</category>
        <category>三方接入</category>
      </categories>
      <tags>
        <tag>pay</tag>
        <tag>alipay</tag>
        <tag>wechatpay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[swift] 星级评分]]></title>
    <url>%2F2017%2F07%2F13%2Fswift-%E6%98%9F%E7%BA%A7%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[许多App都会有评价功能，这个时候或许会需要实现星级评分，下面我们来简单的实现一个星级评分功能。 思路 通过添加图片形式实现星级打分功能.创建两个视图,其中一个添加灰色星星图片,另一个添加橘色星星图片.橘色星星视图覆盖灰色星星视图,通过修改橘色星星视图的宽度实现评分的展现. 创建一个继承于 UIView 的类,作为星级打分的显示视图 创建灰色星星视图,并添加到父视图. 创建橘色星星视图,添加到父视图,保证橘色视图覆盖灰色星星视图. 通过修改橘色星星视图宽度实现评分. 可通过手势等方式实现打分功能. 主要代码创建子视图代码:1234567891011121314private func ay_creatStartView(_ imageName: String) -&gt; UIView &#123; let starView = UIView(frame: CGRect(x: 0, y: 0, width: self.frame.width, height: self.frame.height)) starView.clipsToBounds = true starView.backgroundColor = UIColor.clear starView.isUserInteractionEnabled = false let imgViewWidth = (self.frame.width - CGFloat(totalStarNumber - 1) * 3) / CGFloat(totalStarNumber) for i in 0 ..&lt; totalStarNumber &#123; let imageView = UIImageView(image: UIImage(named: imageName)) imageView.frame = CGRect(x: CGFloat(i) * (imgViewWidth + 3), y: 0, width: imgViewWidth, height: self.frame.height) imageView.contentMode = .scaleAspectFit starView.addSubview(imageView) &#125; return starView &#125; 手指滑动打分代码123456789101112131415override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first let point = touch?.location(in: self) if (point?.x)! &gt;= CGFloat(0) &amp;&amp; (point?.x)! &lt;= self.frame.width &#123; rate = (point?.x)! / self.frame.width delegate?.ay_starRateChange(rate: rate) &#125; &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first let point = touch?.location(in: self) rate = (point?.x)! / self.frame.width delegate?.ay_starRateChange(rate: rate) &#125; 具体实现参考Demo 附加星级评分通过图片实现是最简单的办法,当然也可以通过其他方式实现.例如通过 UIBezierPath 绘制,具体可参考CPSliderView]]></content>
      <categories>
        <category>iOS</category>
        <category>自定义视图</category>
      </categories>
      <tags>
        <tag>自定义视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 UIBezierPath 与 CAShapeLayer 为 UIView 添加边框]]></title>
    <url>%2F2017%2F07%2F12%2F%E9%80%9A%E8%BF%87-CGMutablePath-%E4%B8%BA-UIView-%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[通过贝塞尔曲线与 CAShapeLayer 为 View 添加虚线边框,可设置宽度,颜色,圆角等 代码如下: 123456789101112131415161718192021222324252627282930313233/// 为视图添加虚线边框 /// /// - Parameters: /// - view: 要添加边框的视图 /// - size: 视图 size /// - cornerRadius: 视图圆角 默认:10 /// - lineWidth: 边框宽 默认: 1 /// - lineColor: 边框颜色 默认: black /// - lineDashPattern: 边框段长和间距 默认: [5,3] func addBorderLine(view:UIView, size:CGSize, cornerRadius:CGFloat = 10, lineWidth:CGFloat = 1, lineColor:Color? = Color.black, lineDashPattern: [NSNumber] = [5,3]) -&gt; Void &#123; let shaplayer = CAShapeLayer() shaplayer.bounds = CGRect.init(x: 0, y: 0, width: size.width, height: size.height) shaplayer.anchorPoint = CGPoint.init(x: 0, y: 0) shaplayer.fillColor = Color.clear.cgColor shaplayer.strokeColor = lineColor?.cgColor shaplayer.lineWidth = lineWidth shaplayer.lineJoin = "miter" shaplayer.lineDashPattern = [5,3] let path = CGMutablePath() path.move(to: CGPoint.init(x: lineWidth / 2, y: cornerRadius + lineWidth / 2)) path.addArc(center: CGPoint.init(x: cornerRadius + lineWidth / 2, y: cornerRadius + lineWidth / 2), radius: cornerRadius, startAngle: .pi, endAngle: .pi / 2 * 3, clockwise: false) path.addLine(to: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: lineWidth / 2)) path.addArc(center: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: cornerRadius + lineWidth / 2), radius: cornerRadius, startAngle: .pi / 2 * 3, endAngle: .pi * 2, clockwise: false) path.addLine(to: CGPoint.init(x: size.width - lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2)) path.addArc(center: CGPoint.init(x: size.width - cornerRadius - lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2), radius: cornerRadius, startAngle: 0, endAngle: .pi / 2, clockwise: false) path.addLine(to: CGPoint.init(x: cornerRadius + lineWidth / 2, y: size.height - lineWidth / 2)) path.addArc(center: CGPoint.init(x: cornerRadius + lineWidth / 2, y: size.height - cornerRadius - lineWidth / 2), radius: cornerRadius, startAngle: .pi / 2, endAngle: .pi, clockwise: false) path.addLine(to: CGPoint.init(x: lineWidth / 2, y: cornerRadius + lineWidth / 2)) shaplayer.path = path view.layer.addSublayer(shaplayer) view.layer.masksToBounds = true view.layer.cornerRadius = cornerRadius &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>UIBezierPath</tag>
        <tag>CAShapeLayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常阅读的博客]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%B8%B8%E9%98%85%E8%AF%BB%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我要申明，排名不分前后 iOSObjC 中国 bang’s blog 唐巧的技术博客 蘑菇街李忠 雷纯锋的技术博客 Sergio Chan 自己的博客 casa 的博客 冰霜的博客 串神的博客 南栀的博客 卓同学的博客 判若两人丶的博客 draveness 的博客 Other廖雪峰的官方网站 pandar’s blog]]></content>
      <categories>
        <category>Other</category>
        <category>阅读列表</category>
      </categories>
      <tags>
        <tag>Other</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
